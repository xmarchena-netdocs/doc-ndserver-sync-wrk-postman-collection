{
  "info": {
    "name": "doc-ndserver-sync-wrk - POC (Two Scenarios + Validation)",
    "description": "Proof of Concept for doc-ndserver-sync-wrk synchronization\n\nThis POC demonstrates TWO scenarios with comprehensive validation:\n- Scenario 1: New Document Creation (404 ‚Üí CREATE)\n- Scenario 2: Document Update (200 ‚Üí UPDATE)\n- Validation: Verify data integrity and correctness\n\nAll scenarios run in sequence using the SAME dynamic document ID.\n\nWorkflow:\n1. Load sample with dynamic ID\n2. SCENARIO 1: Create new document\n3. SCENARIO 2: Update the same document\n4. VALIDATION: Verify metadata, versions, ACL, and ModNums",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "00 - Setup",
      "item": [
        {
          "name": "README - How to Use",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "# POC Setup Instructions\n\n## Prerequisites\n\n1. **Import Environment**: Import `doc-ndserver-sync-wrk-POC.postman_environment.json`\n2. **Obtain Tokens**: Run these commands:\n\n```bash\n# Metadata Service Token\n/home/xmarchena/code/idp-docker-utils/service-to-service-cli/service-to-service-cli auth get-access-token --audience doc-metadata-api-svc --scope \"service.create service.read service.update service.delete\"\n\n# Content Service Token\n/home/xmarchena/code/idp-docker-utils/service-to-service-cli/service-to-service-cli auth get-access-token --audience doc-content-api-svc --scope \"service.create service.read service.update service.delete\"\n```\n\n3. **Set Tokens**: Paste tokens into environment variables:\n   - `metadataToken`\n   - `contentToken`\n\n## How to Run POC\n\n1. Run \"01 - Load Sample Document\"\n2. Run folder \"02 - Sync Workflow\" in sequence (or use Runner)\n3. Check console output for detailed logs\n4. Verify document created in metadata API\n\n## Expected Results\n\n‚úÖ Step 1: Returns 404 (document doesn't exist)\n‚úÖ Step 2: Returns 200 (content root updated)\n‚úÖ Step 3: Builds patch request (no API call)\n‚úÖ Step 4: Returns 200 (document created)\n\n## Troubleshooting\n\n- **401 Unauthorized**: Token expired, re-obtain tokens\n- **404 Not Found**: Expected for Step 1 (new document)\n- **Script Errors**: Check console for details"
          },
          "response": []
        },
        {
          "name": "README - ACL Modification Testing",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "# ACL Modification Testing Guide\n\n## Overview\n\nThis guide explains how to test document ACL (Access Control List) modifications using the POC workflow. The test demonstrates a complete CREATE and UPDATE scenario where only the ACL changes, verifying that access control modifications work correctly without affecting other document metadata.\n\n## What is Being Tested\n\n**Scenario:** Modify Access to Document\n- **CREATE** with initial ACL configuration (3 entries)\n- **UPDATE** with modified ACL (4 entries with comprehensive changes)\n- **Validation** that ACL changes applied correctly\n\n## Test Samples\n\n### Initial ACL Configuration\n**Sample:** `sample_acl_initial` (Doc ID: 4817-7714-0018)\n\n| Subject | Type | Rights | Description |\n|---------|------|--------|-------------|\n| DUCOT-pbs.nonadmin | User | VESD | Viewer/Editor/Sharer/Administrator |\n| UG-LGSFSO0I | Group | VESD | Full permissions |\n| NG-8RZI6EOH | Cabinet | V | Viewer only |\n\n**Total:** 3 ACL entries\n\n### Modified ACL Configuration\n**Sample:** `sample_acl_modified` (Same Doc ID: 4817-7714-0018)\n\n| Subject | Type | Rights | Change Type |\n|---------|------|--------|-------------|\n| DUCOT-pbs.nonadmin | User | VE | **MODIFIED** (was VESD, removed S and D) |\n| UG-LGSFSO0I | Group | VESD | **UNCHANGED** |\n| DUCOT-user2 | User | VE | **ADDED** (new user) |\n| UG-NEWGROUP | Group | V | **ADDED** (new group) |\n| ~~NG-8RZI6EOH~~ | ~~Cabinet~~ | ~~V~~ | **REMOVED** (cabinet deleted) |\n\n**Total:** 4 ACL entries (was 3)\n\n**Summary of Changes:**\n- ‚ûï Added: 2 subjects (DUCOT-user2, UG-NEWGROUP)\n- ‚ûñ Removed: 1 subject (Cabinet NG-8RZI6EOH)\n- ‚úèÔ∏è Modified: 1 subject (DUCOT-pbs.nonadmin permissions reduced)\n- ‚úì Unchanged: 1 subject (UG-LGSFSO0I)\n\n## Step-by-Step Workflow\n\n### Phase 1: CREATE with Initial ACL\n\n1. **Load Initial Sample**\n   - Run: `01 - Load Sample Document / Load Sample: ACL Initial`\n   - Generates new dynamic document ID\n   - Sets up initial ACL with 3 entries\n   - Console shows ACL subjects with types and permissions\n\n2. **Upload Content**\n   - Run: Folder `01a - Upload Initial Content` (all requests)\n   - Creates snapshot and uploads content to S3\n   - Required for first-time document creation\n\n3. **CREATE Document**\n   - Run: Folder `02 - Scenario 1: New Document Creation` (all requests)\n   - Step 1: Check existence (expect 404)\n   - Step 2: Configure content root\n   - Step 3: Build CREATE patch request\n   - Step 4: Execute PATCH to create document\n   - **Result:** Document created with 3 ACL entries\n\n### Phase 2: UPDATE with Modified ACL\n\n4. **Load Modified Sample**\n   - Run: `01 - Load Sample Document / Load Sample: ACL Modified`\n   - **IMPORTANT:** Uses SAME document ID from Phase 1\n   - Shows ACL change summary in console (added/removed/modified/unchanged)\n   - No new document ID generated\n\n5. **UPDATE Document (Skip Content Upload)**\n   - Run: Folder `03 - Scenario 2: Document Update` (all requests)\n   - **Do NOT run folder 01a again** - reuses existing snapshot\n   - Step 1: Check existence (expect 200)\n   - Step 2: Update content root (no-op)\n   - Step 3: Build UPDATE patch request (only ACL changed)\n   - Step 4: Execute PATCH to update document\n   - **Result:** Document updated with 4 ACL entries\n\n### Phase 3: Validation\n\n6. **Validate Results**\n   - Run: Folder `04 - Validation` (all requests)\n   - Validates document metadata unchanged\n   - Validates ACL modifications applied correctly\n   - Validates ModNum increments\n   - **Expected:** ~20-25 assertions pass\n\n## Validation Checkpoints\n\n### Document Metadata (Should NOT Change)\n- ‚úì Document name: \"ACL Modification Test Document\" (unchanged)\n- ‚úì Extension: \"txt\" (unchanged)\n- ‚úì NameModNum: Constant between CREATE and UPDATE\n- ‚úì ContentModNum: Constant (no content upload in UPDATE)\n\n### ACL Changes (Should Change)\n- ‚úì Initial: 3 ACL entries\n- ‚úì Updated: 4 ACL entries\n- ‚úì New subjects present: DUCOT-user2, UG-NEWGROUP\n- ‚úì Removed subjects absent: Cabinet NG-8RZI6EOH\n- ‚úì Modified permissions: DUCOT-pbs.nonadmin has VE (not VESD)\n- ‚úì Unchanged subjects: UG-LGSFSO0I still has VESD\n\n### ModNum Behavior\n- ‚úì DocModNum: Increments on UPDATE (expected)\n- ‚úì NameModNum: Stays constant (name unchanged)\n- ‚úì ContentModNum: Stays constant (no content upload)\n\n## Rights Mapping Reference\n\n| Code | Relationship | Description |\n|------|-------------|-------------|\n| V | viewer | Can view document |\n| E | editor | Can edit document |\n| S | sharer | Can share with others |\n| D | administrator | Full admin rights |\n| Z | default | Default permissions |\n\n## Subject Type Detection\n\n| Prefix | Type | Example |\n|--------|------|----------|\n| DUCOT- | User | DUCOT-pbs.nonadmin |\n| UG- | Group | UG-LGSFSO0I |\n| NG- or CA- | Cabinet | NG-8RZI6EOH |\n\n## Technical Notes\n\n- **Transformation Logic:** Uses existing `buildAcl()` function from POC\n- **No Code Changes:** ACL transformation handles add/remove/modify automatically\n- **Same Document ID:** Critical - both samples must use the same ID\n- **No Content Upload:** UPDATE reuses snapshot from CREATE\n- **Independent Test:** Can run separately from other document type scenarios\n\n## Common Issues\n\n**Error: \"Must load ACL Initial sample before loading ACL Modified\"**\n- **Cause:** Tried to load Modified sample first\n- **Fix:** Always load Initial sample first, run CREATE, then load Modified\n\n**Error: Document IDs don't match**\n- **Cause:** Generated new ID for Modified sample\n- **Fix:** Load Sample: ACL Modified reuses existing `documentId` from environment\n\n**Validation Fails: ACL entries don't match expected**\n- **Cause:** Didn't run UPDATE with Modified sample\n- **Fix:** Ensure you loaded Modified sample before running Scenario 2\n\n## Quick Reference: Newman CLI\n\n```bash\n# Run complete ACL modification workflow\ncd /home/xmarchena/code/doc-ndserver-sync-wrk-postman-collection\n\n# Phase 1: CREATE with initial ACL\n./node_modules/.bin/newman run doc-ndserver-sync-wrk-POC.postman_collection.json \\\n  -e doc-ndserver-sync-wrk-POC.postman_environment.json \\\n  --folder \"01 - Load Sample Document\" \\\n  --folder \"01a - Upload Initial Content\" \\\n  --folder \"02 - Scenario 1: New Document Creation\"\n\n# Phase 2: UPDATE with modified ACL\n# (Load Modified sample manually in Postman, then run:)\n./node_modules/.bin/newman run doc-ndserver-sync-wrk-POC.postman_collection.json \\\n  -e doc-ndserver-sync-wrk-POC.postman_environment.json \\\n  --folder \"03 - Scenario 2: Document Update\"\n\n# Phase 3: Validation\n./node_modules/.bin/newman run doc-ndserver-sync-wrk-POC.postman_collection.json \\\n  -e doc-ndserver-sync-wrk-POC.postman_environment.json \\\n  --folder \"04 - Validation\"\n```\n\n## Expected Console Output\n\n### After Loading Initial Sample:\n```\nüé¨ LOADED SAMPLE: ACL Modification - INITIAL\n==================================================\n   Sample: sample_acl_initial\n   Original Template ID: 4817-7714-0018\n   NEW Dynamic ID: 1234-5678-9012\n   Cabinet ID: NG-8RZI6EOH\n   ACL Entry Count: 3\n   ACL Subjects:\n      - DUCOT-pbs.nonadmin (user): VESD\n      - UG-LGSFSO0I (group): VESD\n      - NG-8RZI6EOH (cabinet): V\n\nüìù Next Step: Run CREATE workflow (01a + 02)\n==================================================\n```\n\n### After Loading Modified Sample:\n```\nüîÑ LOADED SAMPLE: ACL Modification - MODIFIED\n==================================================\n   Sample: sample_acl_modified\n   Document ID: 1234-5678-9012 (SAME as initial)\n   Cabinet ID: NG-8RZI6EOH\n   ACL Entry Count: 4\n\n   üìä ACL CHANGES:\n   ‚ûï ADDED:\n      - DUCOT-user2 (VE)\n      - UG-NEWGROUP (V)\n   ‚ûñ REMOVED:\n      - NG-8RZI6EOH (V)\n   ‚úèÔ∏è  MODIFIED:\n      - DUCOT-pbs.nonadmin: VESD ‚Üí VE\n   ‚úì UNCHANGED:\n      - UG-LGSFSO0I (VESD)\n\nüìù Next Step: Run UPDATE workflow (03 only, skip 01a)\n==================================================\n```"
          },
          "response": []
        }
      ]
    },
    {
      "name": "01 - Load Sample Document",
      "item": [
        {
          "name": "Load Sample: Simple Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load simple document sample into nmdMessage",
                  "const sample = pm.environment.get('sample_simple_document');",
                  "",
                  "if (sample) {",
                  "    // Parse the sample",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate a NEW dynamic document ID (format: XXXX-XXXX-XXXX)",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents['1'].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    // Replace the document ID in the entire JSON",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, 'g'), newDocId);",
                  "    ",
                  "    // Update the nmdMessage with new document ID",
                  "    pm.environment.set('nmdMessage', updatedSample);",
                  "    pm.environment.set('documentId', newDocId);",
                  "    pm.environment.set('cabinetId', cabId);",
                  "    ",
                  "    // Store for Scenario 1",
                  "    pm.environment.set('nmdMessage_scenario1', updatedSample);",
                  "    ",
                  "    console.log('üé¨ LOADED SAMPLE FOR TWO SCENARIOS');",
                  "    console.log('='.repeat(50));",
                  "    console.log(`   Original Template ID: ${originalDocId}`);",
                  "    console.log(`   NEW Dynamic ID: ${newDocId}`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log('');",
                  "    console.log('üìù Scenario 1: Will CREATE document (404 ‚Üí 200)');",
                  "    console.log('üìù Scenario 2: Will UPDATE document (200 ‚Üí 200)');",
                  "    console.log('='.repeat(50));",
                  "} else {",
                  "    console.error('‚ùå Sample not found in environment');",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get('nmdMessage');",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to run BOTH scenarios sequentially');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the simple document sample into the nmdMessage environment variable.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Load Sample: DOCX Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load docx document sample into nmdMessage",
                  "const sample = pm.environment.get('sample_docx_document');",
                  "",
                  "if (sample) {",
                  "    // Parse the sample",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate a NEW dynamic document ID (format: XXXX-XXXX-XXXX)",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    // Replace the document ID in the entire JSON",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    // Update the nmdMessage with new document ID",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ LOADED SAMPLE: DOCX Document');",
                  "    console.log(\"=\".repeat(50));",
                  "    console.log(`   Extension: ${extension}`);",
                  "    console.log(`   Original Template ID: ${originalDocId}`);",
                  "    console.log(`   NEW Dynamic ID: ${newDocId}`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log('   üìä Coverage: 25% of production');",
                  "    console.log('   üìù Type: Microsoft Word document');",
                  "    console.log(\"=\".repeat(50));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get(\"nmdMessage\");",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ DOCX Document ready for testing');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the docx document sample into the nmdMessage environment variable.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Load Sample: PDF Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load pdf document sample into nmdMessage",
                  "const sample = pm.environment.get('sample_pdf_document');",
                  "",
                  "if (sample) {",
                  "    // Parse the sample",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate a NEW dynamic document ID (format: XXXX-XXXX-XXXX)",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    // Replace the document ID in the entire JSON",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    // Update the nmdMessage with new document ID",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ LOADED SAMPLE: PDF Document');",
                  "    console.log(\"=\".repeat(50));",
                  "    console.log(`   Extension: ${extension}`);",
                  "    console.log(`   Original Template ID: ${originalDocId}`);",
                  "    console.log(`   NEW Dynamic ID: ${newDocId}`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log('   üìÑ Type: PDF file');",
                  "    console.log('   üìù Read-only document type');",
                  "    console.log(\"=\".repeat(50));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get(\"nmdMessage\");",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ PDF Document ready for testing');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the pdf document sample into the nmdMessage environment variable.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Load Sample: Folder Container",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load folder container sample into nmdMessage",
                  "const sample = pm.environment.get('sample_folder_document');",
                  "",
                  "if (sample) {",
                  "    // Parse the sample",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate a NEW dynamic document ID (format: XXXX-XXXX-XXXX)",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    // Replace the document ID in the entire JSON",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    // Update the nmdMessage with new document ID",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ LOADED SAMPLE: Folder Container');",
                  "    console.log(\"=\".repeat(50));",
                  "    console.log(`   Extension: ${extension}`);",
                  "    console.log(`   Original Template ID: ${originalDocId}`);",
                  "    console.log(`   NEW Dynamic ID: ${newDocId}`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log('   üìÇ Coverage: 8% of production (210+ instances)');",
                  "    console.log('   üìù Type: Folder container (not a file)');",
                  "    console.log(\"=\".repeat(50));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get(\"nmdMessage\");",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Folder Container ready for testing');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the folder container sample into the nmdMessage environment variable.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Load Sample: WOPI Test File",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load wopi test file sample into nmdMessage",
                  "const sample = pm.environment.get('sample_wopi_test');",
                  "",
                  "if (sample) {",
                  "    // Parse the sample",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate a NEW dynamic document ID (format: XXXX-XXXX-XXXX)",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    // Replace the document ID in the entire JSON",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    // Update the nmdMessage with new document ID",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ LOADED SAMPLE: WOPI Test File');",
                  "    console.log(\"=\".repeat(50));",
                  "    console.log(`   Extension: ${extension}`);",
                  "    console.log(`   Original Template ID: ${originalDocId}`);",
                  "    console.log(`   NEW Dynamic ID: ${newDocId}`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log('   ‚òÅÔ∏è Coverage: 12% of production (55+ instances)');",
                  "    console.log('   üìù Type: Office 365 integration test file');",
                  "    console.log(\"=\".repeat(50));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get(\"nmdMessage\");",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ WOPI Test File ready for testing');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the wopi test file sample into the nmdMessage environment variable.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Load Sample: Email Message",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load email message sample into nmdMessage",
                  "const sample = pm.environment.get('sample_email');",
                  "",
                  "if (sample) {",
                  "    // Parse the sample",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate a NEW dynamic document ID (format: XXXX-XXXX-XXXX)",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    // Replace the document ID in the entire JSON",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    // Update the nmdMessage with new document ID",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ LOADED SAMPLE: Email Message');",
                  "    console.log(\"=\".repeat(50));",
                  "    console.log(`   Extension: ${extension}`);",
                  "    console.log(`   Original Template ID: ${originalDocId}`);",
                  "    console.log(`   NEW Dynamic ID: ${newDocId}`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log('   üìß Coverage: 3% of production');",
                  "    console.log('   üìù Type: Email with emailProps metadata');",
                  "    console.log(\"=\".repeat(50));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get(\"nmdMessage\");",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Email Message ready for testing');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the email message sample into the nmdMessage environment variable.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Load Sample: Archived Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load archived document sample into nmdMessage",
                  "const sample = pm.environment.get('sample_archived');",
                  "",
                  "if (sample) {",
                  "    // Parse the sample",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate a NEW dynamic document ID (format: XXXX-XXXX-XXXX)",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    // Replace the document ID in the entire JSON",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    // Update the nmdMessage with new document ID",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ LOADED SAMPLE: Archived Document');",
                  "    console.log(\"=\".repeat(50));",
                  "    console.log(`   Extension: ${extension}`);",
                  "    console.log(`   Original Template ID: ${originalDocId}`);",
                  "    console.log(`   NEW Dynamic ID: ${newDocId}`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log('   üóÉÔ∏è Status: 1 (Archived flag)');",
                  "    console.log('   üìù Type: Tests basic status flag handling');",
                  "    console.log(\"=\".repeat(50));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get(\"nmdMessage\");",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Archived Document ready for testing');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the archived document sample into the nmdMessage environment variable.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Load Sample: ACL Initial",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load ACL Initial sample into nmdMessage",
                  "const sampleName = 'sample_acl_initial';",
                  "const sample = pm.environment.get(sampleName);",
                  "",
                  "if (sample) {",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate a NEW dynamic document ID (format: XXXX-XXXX-XXXX)",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents['1'].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    const aclCount = msg.envProps.acl ? msg.envProps.acl.length : 0;",
                  "    ",
                  "    // Replace the document ID in the entire JSON",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, 'g'), newDocId);",
                  "    ",
                  "    // Update the nmdMessage with new document ID",
                  "    pm.environment.set('nmdMessage', updatedSample);",
                  "    pm.environment.set('documentId', newDocId);",
                  "    pm.environment.set('cabinetId', cabId);",
                  "    ",
                  "    // Store for Scenario 1 (CREATE)",
                  "    pm.environment.set('nmdMessage_scenario1', updatedSample);",
                  "    ",
                  "    console.log('üé¨ LOADED SAMPLE: ACL Modification - INITIAL');",
                  "    console.log('='.repeat(50));",
                  "    console.log(`   Sample: ${sampleName}`);",
                  "    console.log(`   Original Template ID: ${originalDocId}`);",
                  "    console.log(`   NEW Dynamic ID: ${newDocId}`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log(`   ACL Entry Count: ${aclCount}`);",
                  "    ",
                  "    // Log ACL subjects",
                  "    if (msg.envProps.acl) {",
                  "        console.log('   ACL Subjects:');",
                  "        msg.envProps.acl.forEach(entry => {",
                  "            let subjectType = 'user';",
                  "            if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "            if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "            console.log(`      - ${entry.guid} (${subjectType}): ${entry.rights}`);",
                  "        });",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('üìù Next Step: Run CREATE workflow (01a + 02)');",
                  "    console.log('='.repeat(50));",
                  "} else {",
                  "    console.error(`‚ùå Sample '${sampleName}' not found in environment`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get('nmdMessage');",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ ACL Initial sample ready for CREATE workflow');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the ACL modification initial sample with 3 ACL entries for CREATE scenario.\\n\\nInitial ACL Configuration:\\n- User: DUCOT-pbs.nonadmin (VESD - viewer/editor/sharer/admin)\\n- Group: UG-LGSFSO0I (VESD)\\n- Cabinet: NG-8RZI6EOH (V - viewer only)\\n\\nAfter running CREATE, load 'ACL Modified' sample to test UPDATE."
          },
          "response": []
        },
        {
          "name": "Load Sample: ACL Modified",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load ACL Modified sample into nmdMessage",
                  "const sampleName = 'sample_acl_modified';",
                  "const sample = pm.environment.get(sampleName);",
                  "",
                  "if (sample) {",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // IMPORTANT: Use the SAME document ID from current environment",
                  "    const currentDocId = pm.environment.get('documentId');",
                  "    const originalDocId = msg.documents['1'].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    const aclCount = msg.envProps.acl ? msg.envProps.acl.length : 0;",
                  "    ",
                  "    if (!currentDocId) {",
                  "        console.error('‚ùå No documentId found in environment! Load ACL Initial first.');",
                  "        throw new Error('Must load ACL Initial sample before loading ACL Modified');",
                  "    }",
                  "    ",
                  "    // Replace the document ID with the EXISTING one (not a new one)",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, 'g'), currentDocId);",
                  "    ",
                  "    // Update the nmdMessage for UPDATE scenario",
                  "    pm.environment.set('nmdMessage', updatedSample);",
                  "    pm.environment.set('nmdMessage_scenario2', updatedSample);",
                  "    // documentId and cabinetId stay the same",
                  "    ",
                  "    console.log('üîÑ LOADED SAMPLE: ACL Modification - MODIFIED');",
                  "    console.log('='.repeat(50));",
                  "    console.log(`   Sample: ${sampleName}`);",
                  "    console.log(`   Document ID: ${currentDocId} (SAME as initial)`);",
                  "    console.log(`   Cabinet ID: ${cabId}`);",
                  "    console.log(`   ACL Entry Count: ${aclCount}`);",
                  "    ",
                  "    // Get original ACL from Scenario 1 to compare",
                  "    const scenario1Message = pm.environment.get('nmdMessage_scenario1');",
                  "    if (scenario1Message) {",
                  "        const originalMsg = JSON.parse(scenario1Message);",
                  "        const originalAcl = originalMsg.envProps.acl || [];",
                  "        const modifiedAcl = msg.envProps.acl || [];",
                  "        ",
                  "        console.log('');",
                  "        console.log('   üìä ACL CHANGES:');",
                  "        ",
                  "        // Find added subjects",
                  "        const addedSubjects = modifiedAcl.filter(m => ",
                  "            !originalAcl.find(o => o.guid === m.guid)",
                  "        );",
                  "        if (addedSubjects.length > 0) {",
                  "            console.log('   ‚ûï ADDED:');",
                  "            addedSubjects.forEach(s => console.log(`      - ${s.guid} (${s.rights})`));",
                  "        }",
                  "        ",
                  "        // Find removed subjects",
                  "        const removedSubjects = originalAcl.filter(o => ",
                  "            !modifiedAcl.find(m => m.guid === o.guid)",
                  "        );",
                  "        if (removedSubjects.length > 0) {",
                  "            console.log('   ‚ûñ REMOVED:');",
                  "            removedSubjects.forEach(s => console.log(`      - ${s.guid} (${s.rights})`));",
                  "        }",
                  "        ",
                  "        // Find modified permissions",
                  "        const modifiedPerms = modifiedAcl.filter(m => {",
                  "            const orig = originalAcl.find(o => o.guid === m.guid);",
                  "            return orig && orig.rights !== m.rights;",
                  "        });",
                  "        if (modifiedPerms.length > 0) {",
                  "            console.log('   ‚úèÔ∏è  MODIFIED:');",
                  "            modifiedPerms.forEach(m => {",
                  "                const orig = originalAcl.find(o => o.guid === m.guid);",
                  "                console.log(`      - ${m.guid}: ${orig.rights} ‚Üí ${m.rights}`);",
                  "            });",
                  "        }",
                  "        ",
                  "        // Find unchanged",
                  "        const unchangedSubjects = modifiedAcl.filter(m => {",
                  "            const orig = originalAcl.find(o => o.guid === m.guid);",
                  "            return orig && orig.rights === m.rights;",
                  "        });",
                  "        if (unchangedSubjects.length > 0) {",
                  "            console.log('   ‚úì UNCHANGED:');",
                  "            unchangedSubjects.forEach(s => console.log(`      - ${s.guid} (${s.rights})`));",
                  "        }",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('üìù Next Step: Run UPDATE workflow (03 only, skip 01a)');",
                  "    console.log('='.repeat(50));",
                  "} else {",
                  "    console.error(`‚ùå Sample '${sampleName}' not found in environment`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded successfully\", function () {",
                  "    const nmdMessage = pm.environment.get('nmdMessage');",
                  "    pm.expect(nmdMessage).to.not.be.empty;",
                  "});",
                  "",
                  "pm.test(\"Document ID matches initial\", function () {",
                  "    const scenario1 = pm.environment.get('nmdMessage_scenario1');",
                  "    const scenario2 = pm.environment.get('nmdMessage_scenario2');",
                  "    ",
                  "    if (scenario1 && scenario2) {",
                  "        const msg1 = JSON.parse(scenario1);",
                  "        const msg2 = JSON.parse(scenario2);",
                  "        const id1 = msg1.documents['1'].docProps.id;",
                  "        const id2 = msg2.documents['1'].docProps.id;",
                  "        pm.expect(id1).to.equal(id2);",
                  "    }",
                  "});",
                  "",
                  "console.log('‚úÖ ACL Modified sample ready for UPDATE workflow');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Loads the ACL modification modified sample with 4 ACL entries for UPDATE scenario.\\n\\nModified ACL Configuration:\\n- User: DUCOT-pbs.nonadmin (VE - reduced from VESD)\\n- Group: UG-LGSFSO0I (VESD - unchanged)\\n- User: DUCOT-user2 (VE - ADDED)\\n- Group: UG-NEWGROUP (V - ADDED)\\n- Cabinet: NG-8RZI6EOH (REMOVED)\\n\\nChanges: +2 added, -1 removed, 1 modified, 1 unchanged\\n\\nIMPORTANT: Must load ACL Initial first and run CREATE before using this."
          },
          "response": []
        }
      ]
    },
    {
      "name": "01a - Upload Initial Content",
      "item": [
        {
          "name": "Extract Content Metadata from NMD",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Extract content-related metadata from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('sample_simple_document'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const version = doc.versions['1'];",
                  "",
                  "// Extract filename and extension",
                  "const docName = doc.docProps.name;",
                  "const extension = version.verProps.exten;",
                  "const filename = `${docName}.${extension}`;",
                  "",
                  "// Extract user ID and timestamp",
                  "const userId = nmdMessage.envProps.authorguid;",
                  "const createdTimestamp = new Date(parseInt(version.verProps.created.match(/\\d+/)[0])).toISOString();",
                  "",
                  "// Save to environment",
                  "pm.environment.set('contentFilename', filename);",
                  "pm.environment.set('contentExtension', extension);",
                  "pm.environment.set('userId', userId);",
                  "",
                  "console.log('');",
                  "console.log('üìÑ CONTENT METADATA EXTRACTION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üî§ Extension: ${extension}`);",
                  "console.log(`üë§ User ID: ${userId}`);",
                  "console.log(`‚è∞ Created: ${createdTimestamp}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// This is just a setup request, no actual HTTP call needed",
                  "pm.test('Content metadata extracted', function () {",
                  "    const filename = pm.environment.get('contentFilename');",
                  "    const extension = pm.environment.get('contentExtension');",
                  "    const userId = pm.environment.get('userId');",
                  "    ",
                  "    pm.expect(filename).to.not.be.empty;",
                  "    pm.expect(extension).to.not.be.empty;",
                  "    pm.expect(userId).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Content metadata ready for snapshot creation');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Extracts content metadata from NMD message (filename, extension, userId) needed for snapshot creation.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Create Snapshot & Get Presigned URL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('üì∏ CREATING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üåê Requesting presigned URL from Content API...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot created successfully', function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                  "});",
                  "",
                  "const response = pm.response.json();",
                  "",
                  "pm.test('Response contains presigned URL', function () {",
                  "    pm.expect(response.presignedUrl).to.be.a('string');",
                  "    pm.expect(response.presignedUrl).to.include('s3');",
                  "});",
                  "",
                  "// Note: entityId is null initially, gets generated after content upload",
                  "pm.test('Response has entityId field', function () {",
                  "    pm.expect(response).to.have.property('entityId');",
                  "});",
                  "",
                  "// Save presigned URL and object key for later verification",
                  "pm.environment.set('presignedUrl', response.presignedUrl);",
                  "pm.environment.set('snapshotObjectKey', response.objectKey);",
                  "",
                  "console.log('‚úÖ Snapshot created:');",
                  "console.log(`   üì¶ Object Key: ${response.objectKey}`);",
                  "console.log(`   üîó Presigned URL: ${response.presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"contentType\": \"text/plain\",\n  \"filename\": \"{{contentFilename}}\",\n  \"extension\": \"{{contentExtension}}\",\n  \"createdByUserId\": \"{{userId}}\",\n  \"createdTimestamp\": \"{{$isoTimestamp}}\",\n  \"location\": \"poc-test\",\n  \"source\": \"doc-ndserver-sync-wrk-poc\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Creates a snapshot entity in the Content API and retrieves a presigned S3 URL for uploading the document content.\n\nThis corresponds to Phase 1.3 in the integration test."
          },
          "response": []
        },
        {
          "name": "Upload Content to S3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const presignedUrl = pm.environment.get('presignedUrl');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('‚òÅÔ∏è  UPLOADING TO S3');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù File: ${filename}`);",
                  "console.log(`üîó URL: ${presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Content uploaded to S3 successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "console.log('‚úÖ Content uploaded successfully to S3');",
                  "console.log('   üì¶ Document now has both metadata AND content');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/octet-stream"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "This is test content for POC document {{documentId}}.\nCreated at: {{$isoTimestamp}}\nFilename: {{contentFilename}}\n\nThis content was uploaded as part of the doc-ndserver-sync-wrk POC test to verify the complete document lifecycle including content upload to S3."
            },
            "url": {
              "raw": "{{presignedUrl}}",
              "host": [
                "{{presignedUrl}}"
              ]
            },
            "description": "Uploads the document content to S3 using the presigned URL obtained from the Content API.\n\nThis corresponds to Phase 1.4 in the integration test."
          },
          "response": []
        },
        {
          "name": "Verify Snapshot Exists",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const snapshotId = pm.environment.get('snapshotId');",
                  "",
                  "console.log('');",
                  "console.log('üîç VERIFYING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìã Snapshot ID: ${snapshotId}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot retrieved successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "const snapshotResponse = pm.response.json();",
                  "const snapshots = snapshotResponse.results || snapshotResponse;",
                  "const objectKey = pm.environment.get('snapshotObjectKey');",
                  "const expectedExtension = pm.environment.get('contentExtension');",
                  "",
                  "pm.test('Snapshot list contains snapshots', function () {",
                  "    pm.expect(snapshots).to.be.an('array');",
                  "    pm.expect(snapshots.length).to.be.at.least(1);",
                  "});",
                  "",
                  "// Find snapshot by objectKey since entityId is generated after upload",
                  "const createdSnapshot = snapshots.find(s => s.objectKey === objectKey);",
                  "",
                  "pm.test('Created snapshot found in list', function () {",
                  "    pm.expect(createdSnapshot).to.not.be.undefined;",
                  "});",
                  "",
                  "pm.test('Snapshot has correct extension', function () {",
                  "    pm.expect(createdSnapshot.extension).to.equal(expectedExtension);",
                  "});",
                  "",
                  "pm.test('Snapshot has content uploaded', function () {",
                  "    pm.expect(createdSnapshot.length).to.be.above(0);",
                  "});",
                  "",
                  "console.log('‚úÖ Snapshot verified:');",
                  "console.log(`   üìã Entity ID: ${createdSnapshot.entityId}`);",
                  "console.log(`   üî§ Extension: ${createdSnapshot.extension}`);",
                  "console.log(`   üì¶ Size: ${createdSnapshot.length} bytes`);",
                  "console.log(`   ‚úîÔ∏è  Content upload complete!`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Verifies that the snapshot was successfully created and contains the uploaded content."
          },
          "response": []
        }
      ],
      "description": "Creates a content snapshot and uploads document content to S3.\n\nThis folder adds the content upload workflow between initial setup and the two test scenarios. It:\n1. Extracts content metadata from the NMD message\n2. Creates a snapshot entity and gets a presigned S3 URL\n3. Uploads content to S3 using the presigned URL\n4. Verifies the snapshot was created successfully\n\nThis ensures documents have both metadata AND content before testing sync scenarios."
    },
    {
      "name": "02 - SCENARIO 1: New Document Creation",
      "item": [
        {
          "name": "S1 - Step 1: Check Document Existence (Expect 404)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "pm.environment.set('nmdMessage', pm.environment.get('nmdMessage_scenario1'));",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 1: NEW DOCUMENT CREATION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 404 (document doesn't exist)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(404);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'true');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document not found (404)');",
                  "console.log('   Ready to CREATE new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Checks if the document already exists in the metadata API.\n\nExpected for POC: 404 Not Found (new document)"
          },
          "response": []
        },
        {
          "name": "S1 - Step 2: Configure Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Build documentRoot from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "",
                  "// Format: [\"NG-CABID/documents\"]",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "",
                  "console.log(`üìÅ Configuring content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 204 (content root set)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root configured for new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            },
            "description": "Updates the content service metadata to set the document root location.\n\nThis configures where content files are stored in S3."
          },
          "response": []
        },
        {
          "name": "S1 - Step 3: Build CREATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === MINIMAL TRANSFORMATION FOR POC ===",
                  "// This is a simplified version for new document creation only",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "// Helper: Convert NetDocuments date format",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "// Helper: Build ACL",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = {",
                  "        'V': 'viewer',",
                  "        'E': 'editor',",
                  "        'S': 'sharer',",
                  "        'D': 'administrator',",
                  "        'Z': 'default'",
                  "    };",
                  "    ",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        ",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        ",
                  "        return {",
                  "            SubjectType: subjectType,",
                  "            SubjectId: entry.guid,",
                  "            Relations: relations",
                  "        };",
                  "    });",
                  "}",
                  "",
                  "// Helper: Build versions list",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    ",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        ",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: {",
                  "                UserId: props.creatorguid,",
                  "                Timestamp: convertDate(props.created)",
                  "            },",
                  "            Modified: {",
                  "                UserId: props.modifiedByGuid || props.creatorguid,",
                  "                Timestamp: convertDate(props.modified || props.created)",
                  "            },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    ",
                  "    return versionsList;",
                  "}",
                  "",
                  "// Build minimal patch request for NEW document",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: docProps.name,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum),",
                  "    NameModNum: parseInt(docProps.nameModNum),",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: {",
                  "        UserId: envProps.authorguid,",
                  "        Timestamp: convertDate(envProps.created)",
                  "    },",
                  "    Modified: {",
                  "        UserId: envProps['modified by guid'],",
                  "        Timestamp: convertDate(envProps.modified)",
                  "    },",
                  "    CheckedOut: {",
                  "        UserId: null,",
                  "        Timestamp: null,",
                  "        Comment: null,",
                  "        CollaborationEdit: null,",
                  "        CollaborationEditType: null",
                  "    },",
                  "    Locked: {",
                  "        UserId: null,",
                  "        Comment: null,",
                  "        Timestamp: null",
                  "    },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "",
                  "console.log('‚úÖ CREATE patch request built');",
                  "console.log(`   Document: ${patchRequest.Name}`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to CREATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Builds the patch request by transforming the NMD message.\n\nThis is a dummy request that only runs the pre-request script to build the patchRequest variable.\n\nFor POC: Simplified transformation for new document creation only."
          },
          "response": []
        },
        {
          "name": "S1 - Step 4: CREATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üöÄ CREATING new document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Document created successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "",
                  "// Store created document for Scenario 2",
                  "pm.environment.set('scenario1_created_document', JSON.stringify(response));",
                  "pm.environment.set('scenario1_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 1 COMPLETE: Document CREATED');",
                  "console.log('üìä Created Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Cabinet ID: ${response.cabinetId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${response.acl ? response.acl.length : 0}`);",
                  "console.log('');",
                  "console.log('‚û°Ô∏è  Document ready for Scenario 2 (UPDATE)');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Creates/updates the document in the metadata API.\n\nFor POC: Creates a new document with metadata, versions, and ACLs.\n\nThis is the main synchronization call."
          },
          "response": []
        }
      ]
    },
    {
      "name": "03 - SCENARIO 2: Document Update",
      "item": [
        {
          "name": "S2 - Step 1: Check Document Existence (Expect 200)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 2: DOCUMENT UPDATE');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists (should be 200)...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 200 (document exists)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var extendedDoc = pm.response.json();",
                  "pm.environment.set('existingDocument', JSON.stringify(extendedDoc));",
                  "pm.environment.set('scenario2_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'false');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document found (200 OK)');",
                  "console.log(`   Document State: ${extendedDoc.state}`);",
                  "console.log(`   Current Versions: ${extendedDoc.versions ? extendedDoc.versions.length : 0}`);",
                  "console.log('   Ready to UPDATE existing document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 2: Update Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "console.log(`üìÅ Updating content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 204 (content root updated)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario2_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root updated');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 3: Build UPDATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === BUILD PATCH REQUEST FOR UPDATING DOCUMENT ===",
                  "// This simulates a change: update document name with timestamp",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = { 'V': 'viewer', 'E': 'editor', 'S': 'sharer', 'D': 'administrator', 'Z': 'default' };",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        return { SubjectType: subjectType, SubjectId: entry.guid, Relations: relations };",
                  "    });",
                  "}",
                  "",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: { UserId: props.creatorguid, Timestamp: convertDate(props.created) },",
                  "            Modified: { UserId: props.modifiedByGuid || props.creatorguid, Timestamp: convertDate(props.modified || props.created) },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    return versionsList;",
                  "}",
                  "",
                  "// SIMULATE A CHANGE: Update document name",
                  "const updatedName = docProps.name + ' [UPDATED]';",
                  "const now = new Date().toISOString();",
                  "",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: updatedName,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum) + 1,",
                  "    NameModNum: parseInt(docProps.nameModNum) + 1,",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: { UserId: envProps.authorguid, Timestamp: convertDate(envProps.created) },",
                  "    Modified: { UserId: envProps['modified by guid'], Timestamp: now },",
                  "    CheckedOut: { UserId: null, Timestamp: null, Comment: null, CollaborationEdit: null, CollaborationEditType: null },",
                  "    Locked: { UserId: null, Comment: null, Timestamp: null },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "console.log('‚úÖ UPDATE patch request built');",
                  "console.log(`   CHANGE: Name updated to: ${updatedName}`);",
                  "console.log(`   CHANGE: Modified timestamp: ${now}`);",
                  "console.log(`   CHANGE: DocModNum incremented`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to UPDATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 4: UPDATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üîÑ UPDATING existing document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Document updated successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "pm.environment.set('scenario2_updated_document', JSON.stringify(response));",
                  "pm.environment.set('scenario2_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 2 COMPLETE: Document UPDATED');",
                  "console.log('üìä Updated Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log('');",
                  "console.log('üéâ BOTH SCENARIOS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã SUMMARY:');",
                  "console.log(`   Scenario 1 - Step 1: ${pm.environment.get('scenario1_step1_status')} (Expected: 404)`);",
                  "console.log(`   Scenario 1 - Step 4: ${pm.environment.get('scenario1_step4_status')} (Expected: 200 - CREATE)`);",
                  "console.log(`   Scenario 2 - Step 1: ${pm.environment.get('scenario2_step1_status')} (Expected: 200 - EXISTS)`);",
                  "console.log(`   Scenario 2 - Step 4: ${pm.environment.get('scenario2_step4_status')} (Expected: 200 - UPDATE)`);",
                  "console.log('');",
                  "console.log('‚úÖ POC validated BOTH workflows successfully!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        }
      ]
    },
    {
      "name": "04 - Validation",
      "item": [
        {
          "name": "Validate Document Metadata",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Document Metadata');",
                  "console.log('='.repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get('documentId')}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document exists (200 OK)', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "var expectedDocId = pm.environment.get('documentId');",
                  "",
                  "pm.test('Document ID matches', function () {",
                  "    pm.expect(doc.documentId).to.eql(expectedDocId);",
                  "});",
                  "",
                  "pm.test('Document state is ACTIVE', function () {",
                  "    pm.expect(doc.state).to.eql('ACTIVE');",
                  "});",
                  "",
                  "pm.test('Cabinet ID is set', function () {",
                  "    pm.expect(doc.cabinetId).to.not.be.empty;",
                  "    pm.expect(doc.cabinetId).to.eql('NG-8RZI6EOH');",
                  "});",
                  "",
                  "pm.test('Document name was updated in Scenario 2', function () {",
                  "    pm.expect(doc.name).to.include('[UPDATED]');",
                  "});",
                  "",
                  "pm.test('EnvUrl is set', function () {",
                  "    pm.expect(doc.envUrl).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ Document Metadata Validation:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document created in Scenario 1 and updated in Scenario 2 exists with correct metadata."
          },
          "response": []
        },
        {
          "name": "Validate Versions",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Version Information');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has versions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.versions).to.be.an('array');",
                  "    pm.expect(doc.versions.length).to.be.at.least(1);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.versions && doc.versions.length > 0) {",
                  "    var version1 = doc.versions[0];",
                  "    ",
                  "    pm.test('Version 1 exists', function () {",
                  "        pm.expect(version1.versionId).to.eql(1);",
                  "    });",
                  "    ",
                  "    pm.test('Version has extension', function () {",
                  "        pm.expect(version1.extension).to.eql('txt');",
                  "    });",
                  "    ",
                  "    pm.test('Version has label', function () {",
                  "        pm.expect(version1.label).to.eql('1.0');",
                  "    });",
                  "    ",
                  "    pm.test('Version state is ACTIVE', function () {",
                  "        pm.expect(version1.state).to.eql('ACTIVE');",
                  "    });",
                  "    ",
                  "    pm.test('Version has created timestamp', function () {",
                  "        pm.expect(version1.created).to.have.property('timestamp');",
                  "        pm.expect(version1.created.timestamp).to.not.be.empty;",
                  "    });",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ Version Validation:');",
                  "    console.log(`   Version ID: ${version1.versionId}`);",
                  "    console.log(`   Label: ${version1.label}`);",
                  "    console.log(`   Extension: ${version1.extension}`);",
                  "    console.log(`   Size: ${version1.size} bytes`);",
                  "    console.log(`   State: ${version1.state}`);",
                  "    console.log(`   Created: ${version1.created.timestamp}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document has the correct version information from the NMD message."
          },
          "response": []
        },
        {
          "name": "Validate ACL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying ACL Configuration');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ACL permissions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.aclPermissions).to.be.an('object');",
                  "    pm.expect(doc.aclPermissions.relationships).to.be.an('array');",
                  "    pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.aclPermissions && doc.aclPermissions.relationships) {",
                  "    pm.test('ACL has expected entries', function () {",
                  "        pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "    });",
                  "    ",
                  "    var groupAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'UG-LGSFSO0I');",
                  "    var userAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'DUCOT-pbs.nonadmin');",
                  "    ",
                  "    pm.test('Group ACL entry exists', function () {",
                  "        pm.expect(groupAcl).to.not.be.undefined;",
                  "        pm.expect(groupAcl.subjectType).to.eql('group');",
                  "    });",
                  "    ",
                  "    pm.test('User ACL entry exists', function () {",
                  "        pm.expect(userAcl).to.not.be.undefined;",
                  "        pm.expect(userAcl.subjectType).to.eql('user');",
                  "    });",
                  "    ",
                  "    pm.test('ACL has correct relationships (VESD)', function () {",
                  "        pm.expect(groupAcl.relationships).to.include('viewer');",
                  "        pm.expect(groupAcl.relationships).to.include('editor');",
                  "        pm.expect(groupAcl.relationships).to.include('sharer');",
                  "        pm.expect(groupAcl.relationships).to.include('administrator');",
                  "    });",
                  "    ",
                  "    // ACL MODIFICATION TESTS (optional - only run if scenario1Message exists)",
                  "    const scenario1Message = pm.environment.get('nmdMessage_scenario1');",
                  "    const scenario2Message = pm.environment.get('nmdMessage_scenario2');",
                  "    ",
                  "    if (scenario1Message && scenario2Message) {",
                  "        const msg1 = JSON.parse(scenario1Message);",
                  "        const msg2 = JSON.parse(scenario2Message);",
                  "        ",
                  "        // Check if this is an ACL modification test",
                  "        if (msg1.documents && msg1.documents['1'].docProps.name.includes('ACL Modification')) {",
                  "            console.log('');",
                  "            console.log('üî¨ ACL MODIFICATION TEST DETECTED');",
                  "            console.log('   Running enhanced ACL validation...');",
                  "            ",
                  "            const initialAcl = msg1.envProps.acl || [];",
                  "            const modifiedAcl = msg2.envProps.acl || [];",
                  "            const actualAcl = doc.aclPermissions.relationships;",
                  "            ",
                  "            pm.test('ACL Modification: Entry count matches modified sample', function () {",
                  "                pm.expect(actualAcl.length).to.equal(modifiedAcl.length);",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New user DUCOT-user2 present', function () {",
                  "                const user2 = actualAcl.find(e => e.subjectId === 'DUCOT-user2');",
                  "                pm.expect(user2).to.not.be.undefined;",
                  "                pm.expect(user2.subjectType).to.eql('user');",
                  "                pm.expect(user2.relationships).to.include('viewer');",
                  "                pm.expect(user2.relationships).to.include('editor');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New group UG-NEWGROUP present', function () {",
                  "                const newGroup = actualAcl.find(e => e.subjectId === 'UG-NEWGROUP');",
                  "                pm.expect(newGroup).to.not.be.undefined;",
                  "                pm.expect(newGroup.subjectType).to.eql('group');",
                  "                pm.expect(newGroup.relationships).to.include('viewer');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: Cabinet NG-8RZI6EOH removed', function () {",
                  "                const cabinet = actualAcl.find(e => e.subjectId === 'NG-8RZI6EOH');",
                  "                pm.expect(cabinet).to.be.undefined;",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: DUCOT-pbs.nonadmin permissions modified (VE only)', function () {",
                  "                const user = actualAcl.find(e => e.subjectId === 'DUCOT-pbs.nonadmin');",
                  "                pm.expect(user).to.not.be.undefined;",
                  "                pm.expect(user.relationships).to.include('viewer');",
                  "                pm.expect(user.relationships).to.include('editor');",
                  "                pm.expect(user.relationships).to.not.include('sharer');",
                  "                pm.expect(user.relationships).to.not.include('administrator');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: UG-LGSFSO0I unchanged (VESD)', function () {",
                  "                const group = actualAcl.find(e => e.subjectId === 'UG-LGSFSO0I');",
                  "                pm.expect(group).to.not.be.undefined;",
                  "                pm.expect(group.relationships).to.include('viewer');",
                  "                pm.expect(group.relationships).to.include('editor');",
                  "                pm.expect(group.relationships).to.include('sharer');",
                  "                pm.expect(group.relationships).to.include('administrator');",
                  "            });",
                  "            ",
                  "            console.log('   ‚úÖ ACL modification validation complete');",
                  "        }",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ ACL Validation:');",
                  "    console.log(`   Object Type: ${doc.aclPermissions.objectType}`);",
                  "    console.log(`   Object ID: ${doc.aclPermissions.objectId}`);",
                  "    console.log(`   Total ACL Entries: ${doc.aclPermissions.relationships.length}`);",
                  "    doc.aclPermissions.relationships.forEach((entry, idx) => {",
                  "        console.log(`   Entry ${idx + 1}:`);",
                  "        console.log(`      Subject: ${entry.subjectId} (${entry.subjectType})`);",
                  "        console.log(`      Relationships: ${entry.relationships.join(', ')}`);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the ACL was correctly transformed from NMD format (VESD) to SpiceDB relations (viewer, editor, sharer, administrator)."
          },
          "response": []
        },
        {
          "name": "Validate ModNums",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Modification Numbers');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ModNums', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.docModNum).to.not.be.null;",
                  "    pm.expect(doc.nameModNum).to.not.be.null;",
                  "    pm.expect(doc.contentModNum).to.not.be.null;",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "pm.test('ModNums are valid ISO 8601 timestamps', function () {",
                  "    var isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;",
                  "    pm.expect(doc.docModNum).to.match(isoRegex);",
                  "    pm.expect(doc.nameModNum).to.match(isoRegex);",
                  "    pm.expect(doc.contentModNum).to.match(isoRegex);",
                  "});",
                  "",
                  "pm.test('Document has modified timestamp', function () {",
                  "    pm.expect(doc.modified).to.have.property('timestamp');",
                  "    pm.expect(doc.modified.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "pm.test('Document has created timestamp', function () {",
                  "    pm.expect(doc.created).to.have.property('timestamp');",
                  "    pm.expect(doc.created.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ ModNum Validation:');",
                  "console.log(`   DocModNum: ${doc.docModNum} (ISO 8601 format)`);",
                  "console.log(`   NameModNum: ${doc.nameModNum}`);",
                  "console.log(`   ContentModNum: ${doc.contentModNum}`);",
                  "console.log(`   Created: ${doc.created.timestamp}`);",
                  "console.log(`   Modified: ${doc.modified.timestamp}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that modification numbers (ModNums) were correctly set and incremented between scenarios."
          },
          "response": []
        },
        {
          "name": "Validation Summary",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üìä FINAL VALIDATION SUMMARY');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var doc = pm.response.json();",
                  "",
                  "console.log('');",
                  "console.log('üéâ ALL VALIDATIONS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã Complete Document State:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   Official Version: ${doc.officialVersion}`);",
                  "console.log(`   Next Version: ${doc.nextVersion}`);",
                  "console.log(`   Versions Count: ${doc.versions ? doc.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${doc.acl ? doc.acl.length : 0}`);",
                  "console.log(`   DocModNum: ${doc.docModNum}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);",
                  "console.log('');",
                  "console.log('‚úÖ Scenario 1 (CREATE): Verified');",
                  "console.log('‚úÖ Scenario 2 (UPDATE): Verified');",
                  "console.log('‚úÖ Data Integrity: Confirmed');",
                  "console.log('');",
                  "console.log('='.repeat(50));",
                  "console.log('‚úÖ POC VALIDATION SUCCESSFUL!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Final validation that prints a comprehensive summary of the document state after both scenarios."
          },
          "response": []
        }
      ]
    },
    {
      "name": "05 - Test Scenario: DOCX Document",
      "item": [
        {
          "name": "Step 1: Load DOCX Document Sample",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load DOCX Document sample",
                  "const sample = pm.environment.get('sample_docx_document');",
                  "",
                  "if (sample) {",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate dynamic document ID",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ TEST SCENARIO: DOCX DOCUMENT');",
                  "    console.log(\"=\".repeat(60));",
                  "    console.log('   DOCX (Word) document - 25% of production');",
                  "    console.log(`   Document ID: ${newDocId}`);",
                  "    console.log(\"=\".repeat(60));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded\", function () {",
                  "    pm.expect(pm.environment.get(\"nmdMessage\")).to.not.be.empty;",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Extract Content Metadata from NMD",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Extract content-related metadata from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('sample_docx_document'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const version = doc.versions['1'];",
                  "",
                  "// Extract filename and extension",
                  "const docName = doc.docProps.name;",
                  "const extension = version.verProps.exten;",
                  "const filename = `${docName}.${extension}`;",
                  "",
                  "// Extract user ID and timestamp",
                  "const userId = nmdMessage.envProps.authorguid;",
                  "const createdTimestamp = new Date(parseInt(version.verProps.created.match(/\\d+/)[0])).toISOString();",
                  "",
                  "// Save to environment",
                  "pm.environment.set('contentFilename', filename);",
                  "pm.environment.set('contentExtension', extension);",
                  "pm.environment.set('userId', userId);",
                  "",
                  "console.log('');",
                  "console.log('üìÑ CONTENT METADATA EXTRACTION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üî§ Extension: ${extension}`);",
                  "console.log(`üë§ User ID: ${userId}`);",
                  "console.log(`‚è∞ Created: ${createdTimestamp}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// This is just a setup request, no actual HTTP call needed",
                  "pm.test('Content metadata extracted', function () {",
                  "    const filename = pm.environment.get('contentFilename');",
                  "    const extension = pm.environment.get('contentExtension');",
                  "    const userId = pm.environment.get('userId');",
                  "    ",
                  "    pm.expect(filename).to.not.be.empty;",
                  "    pm.expect(extension).to.not.be.empty;",
                  "    pm.expect(userId).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Content metadata ready for snapshot creation');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Extracts content metadata from NMD message (filename, extension, userId) needed for snapshot creation.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Create Snapshot & Get Presigned URL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('üì∏ CREATING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üåê Requesting presigned URL from Content API...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot created successfully', function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                  "});",
                  "",
                  "const response = pm.response.json();",
                  "",
                  "pm.test('Response contains presigned URL', function () {",
                  "    pm.expect(response.presignedUrl).to.be.a('string');",
                  "    pm.expect(response.presignedUrl).to.include('s3');",
                  "});",
                  "",
                  "// Note: entityId is null initially, gets generated after content upload",
                  "pm.test('Response has entityId field', function () {",
                  "    pm.expect(response).to.have.property('entityId');",
                  "});",
                  "",
                  "// Save presigned URL and object key for later verification",
                  "pm.environment.set('presignedUrl', response.presignedUrl);",
                  "pm.environment.set('snapshotObjectKey', response.objectKey);",
                  "",
                  "console.log('‚úÖ Snapshot created:');",
                  "console.log(`   üì¶ Object Key: ${response.objectKey}`);",
                  "console.log(`   üîó Presigned URL: ${response.presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"contentType\": \"text/plain\",\n  \"filename\": \"{{contentFilename}}\",\n  \"extension\": \"{{contentExtension}}\",\n  \"createdByUserId\": \"{{userId}}\",\n  \"createdTimestamp\": \"{{$isoTimestamp}}\",\n  \"location\": \"poc-test\",\n  \"source\": \"doc-ndserver-sync-wrk-poc\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Creates a snapshot entity in the Content API and retrieves a presigned S3 URL for uploading the document content.\n\nThis corresponds to Phase 1.3 in the integration test."
          },
          "response": []
        },
        {
          "name": "Upload Content to S3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const presignedUrl = pm.environment.get('presignedUrl');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('‚òÅÔ∏è  UPLOADING TO S3');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù File: ${filename}`);",
                  "console.log(`üîó URL: ${presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Content uploaded to S3 successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "console.log('‚úÖ Content uploaded successfully to S3');",
                  "console.log('   üì¶ Document now has both metadata AND content');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/octet-stream"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "This is test content for POC document {{documentId}}.\nCreated at: {{$isoTimestamp}}\nFilename: {{contentFilename}}\n\nThis content was uploaded as part of the doc-ndserver-sync-wrk POC test to verify the complete document lifecycle including content upload to S3."
            },
            "url": {
              "raw": "{{presignedUrl}}",
              "host": [
                "{{presignedUrl}}"
              ]
            },
            "description": "Uploads the document content to S3 using the presigned URL obtained from the Content API.\n\nThis corresponds to Phase 1.4 in the integration test."
          },
          "response": []
        },
        {
          "name": "Verify Snapshot Exists",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const snapshotId = pm.environment.get('snapshotId');",
                  "",
                  "console.log('');",
                  "console.log('üîç VERIFYING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìã Snapshot ID: ${snapshotId}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot retrieved successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "const snapshotResponse = pm.response.json();",
                  "const snapshots = snapshotResponse.results || snapshotResponse;",
                  "const objectKey = pm.environment.get('snapshotObjectKey');",
                  "const expectedExtension = pm.environment.get('contentExtension');",
                  "",
                  "pm.test('Snapshot list contains snapshots', function () {",
                  "    pm.expect(snapshots).to.be.an('array');",
                  "    pm.expect(snapshots.length).to.be.at.least(1);",
                  "});",
                  "",
                  "// Find snapshot by objectKey since entityId is generated after upload",
                  "const createdSnapshot = snapshots.find(s => s.objectKey === objectKey);",
                  "",
                  "pm.test('Created snapshot found in list', function () {",
                  "    pm.expect(createdSnapshot).to.not.be.undefined;",
                  "});",
                  "",
                  "pm.test('Snapshot has correct extension', function () {",
                  "    pm.expect(createdSnapshot.extension).to.equal(expectedExtension);",
                  "});",
                  "",
                  "pm.test('Snapshot has content uploaded', function () {",
                  "    pm.expect(createdSnapshot.length).to.be.above(0);",
                  "});",
                  "",
                  "console.log('‚úÖ Snapshot verified:');",
                  "console.log(`   üìã Entity ID: ${createdSnapshot.entityId}`);",
                  "console.log(`   üî§ Extension: ${createdSnapshot.extension}`);",
                  "console.log(`   üì¶ Size: ${createdSnapshot.length} bytes`);",
                  "console.log(`   ‚úîÔ∏è  Content upload complete!`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Verifies that the snapshot was successfully created and contains the uploaded content."
          },
          "response": []
        },
        {
          "name": "S1 - Step 1: Check Document Existence (Expect 404)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "pm.environment.set('nmdMessage', pm.environment.get('nmdMessage_scenario1'));",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 1: NEW DOCUMENT CREATION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 404 (document doesn't exist)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(404);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'true');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document not found (404)');",
                  "console.log('   Ready to CREATE new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Checks if the document already exists in the metadata API.\n\nExpected for POC: 404 Not Found (new document)"
          },
          "response": []
        },
        {
          "name": "S1 - Step 2: Configure Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Build documentRoot from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "",
                  "// Format: [\"NG-CABID/documents\"]",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "",
                  "console.log(`üìÅ Configuring content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 204 (content root set)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root configured for new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            },
            "description": "Updates the content service metadata to set the document root location.\n\nThis configures where content files are stored in S3."
          },
          "response": []
        },
        {
          "name": "S1 - Step 3: Build CREATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === MINIMAL TRANSFORMATION FOR POC ===",
                  "// This is a simplified version for new document creation only",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "// Helper: Convert NetDocuments date format",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "// Helper: Build ACL",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = {",
                  "        'V': 'viewer',",
                  "        'E': 'editor',",
                  "        'S': 'sharer',",
                  "        'D': 'administrator',",
                  "        'Z': 'default'",
                  "    };",
                  "    ",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        ",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        ",
                  "        return {",
                  "            SubjectType: subjectType,",
                  "            SubjectId: entry.guid,",
                  "            Relations: relations",
                  "        };",
                  "    });",
                  "}",
                  "",
                  "// Helper: Build versions list",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    ",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        ",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: {",
                  "                UserId: props.creatorguid,",
                  "                Timestamp: convertDate(props.created)",
                  "            },",
                  "            Modified: {",
                  "                UserId: props.modifiedByGuid || props.creatorguid,",
                  "                Timestamp: convertDate(props.modified || props.created)",
                  "            },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    ",
                  "    return versionsList;",
                  "}",
                  "",
                  "// Build minimal patch request for NEW document",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: docProps.name,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum),",
                  "    NameModNum: parseInt(docProps.nameModNum),",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: {",
                  "        UserId: envProps.authorguid,",
                  "        Timestamp: convertDate(envProps.created)",
                  "    },",
                  "    Modified: {",
                  "        UserId: envProps['modified by guid'],",
                  "        Timestamp: convertDate(envProps.modified)",
                  "    },",
                  "    CheckedOut: {",
                  "        UserId: null,",
                  "        Timestamp: null,",
                  "        Comment: null,",
                  "        CollaborationEdit: null,",
                  "        CollaborationEditType: null",
                  "    },",
                  "    Locked: {",
                  "        UserId: null,",
                  "        Comment: null,",
                  "        Timestamp: null",
                  "    },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "",
                  "console.log('‚úÖ CREATE patch request built');",
                  "console.log(`   Document: ${patchRequest.Name}`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to CREATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Builds the patch request by transforming the NMD message.\n\nThis is a dummy request that only runs the pre-request script to build the patchRequest variable.\n\nFor POC: Simplified transformation for new document creation only."
          },
          "response": []
        },
        {
          "name": "S1 - Step 4: CREATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üöÄ CREATING new document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Document created successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "",
                  "// Store created document for Scenario 2",
                  "pm.environment.set('scenario1_created_document', JSON.stringify(response));",
                  "pm.environment.set('scenario1_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 1 COMPLETE: Document CREATED');",
                  "console.log('üìä Created Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Cabinet ID: ${response.cabinetId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${response.acl ? response.acl.length : 0}`);",
                  "console.log('');",
                  "console.log('‚û°Ô∏è  Document ready for Scenario 2 (UPDATE)');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Creates/updates the document in the metadata API.\n\nFor POC: Creates a new document with metadata, versions, and ACLs.\n\nThis is the main synchronization call."
          },
          "response": []
        },
        {
          "name": "S2 - Step 1: Check Document Existence (Expect 200)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 2: DOCUMENT UPDATE');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists (should be 200)...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 200 (document exists)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var extendedDoc = pm.response.json();",
                  "pm.environment.set('existingDocument', JSON.stringify(extendedDoc));",
                  "pm.environment.set('scenario2_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'false');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document found (200 OK)');",
                  "console.log(`   Document State: ${extendedDoc.state}`);",
                  "console.log(`   Current Versions: ${extendedDoc.versions ? extendedDoc.versions.length : 0}`);",
                  "console.log('   Ready to UPDATE existing document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 2: Update Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "console.log(`üìÅ Updating content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 204 (content root updated)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario2_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root updated');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 3: Build UPDATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === BUILD PATCH REQUEST FOR UPDATING DOCUMENT ===",
                  "// This simulates a change: update document name with timestamp",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = { 'V': 'viewer', 'E': 'editor', 'S': 'sharer', 'D': 'administrator', 'Z': 'default' };",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        return { SubjectType: subjectType, SubjectId: entry.guid, Relations: relations };",
                  "    });",
                  "}",
                  "",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: { UserId: props.creatorguid, Timestamp: convertDate(props.created) },",
                  "            Modified: { UserId: props.modifiedByGuid || props.creatorguid, Timestamp: convertDate(props.modified || props.created) },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    return versionsList;",
                  "}",
                  "",
                  "// SIMULATE A CHANGE: Update document name",
                  "const updatedName = docProps.name + ' [UPDATED]';",
                  "const now = new Date().toISOString();",
                  "",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: updatedName,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum) + 1,",
                  "    NameModNum: parseInt(docProps.nameModNum) + 1,",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: { UserId: envProps.authorguid, Timestamp: convertDate(envProps.created) },",
                  "    Modified: { UserId: envProps['modified by guid'], Timestamp: now },",
                  "    CheckedOut: { UserId: null, Timestamp: null, Comment: null, CollaborationEdit: null, CollaborationEditType: null },",
                  "    Locked: { UserId: null, Comment: null, Timestamp: null },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "console.log('‚úÖ UPDATE patch request built');",
                  "console.log(`   CHANGE: Name updated to: ${updatedName}`);",
                  "console.log(`   CHANGE: Modified timestamp: ${now}`);",
                  "console.log(`   CHANGE: DocModNum incremented`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to UPDATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 4: UPDATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üîÑ UPDATING existing document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Document updated successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "pm.environment.set('scenario2_updated_document', JSON.stringify(response));",
                  "pm.environment.set('scenario2_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 2 COMPLETE: Document UPDATED');",
                  "console.log('üìä Updated Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log('');",
                  "console.log('üéâ BOTH SCENARIOS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã SUMMARY:');",
                  "console.log(`   Scenario 1 - Step 1: ${pm.environment.get('scenario1_step1_status')} (Expected: 404)`);",
                  "console.log(`   Scenario 1 - Step 4: ${pm.environment.get('scenario1_step4_status')} (Expected: 200 - CREATE)`);",
                  "console.log(`   Scenario 2 - Step 1: ${pm.environment.get('scenario2_step1_status')} (Expected: 200 - EXISTS)`);",
                  "console.log(`   Scenario 2 - Step 4: ${pm.environment.get('scenario2_step4_status')} (Expected: 200 - UPDATE)`);",
                  "console.log('');",
                  "console.log('‚úÖ POC validated BOTH workflows successfully!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Validate Document Metadata",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Document Metadata');",
                  "console.log('='.repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get('documentId')}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document exists (200 OK)', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "var expectedDocId = pm.environment.get('documentId');",
                  "",
                  "pm.test('Document ID matches', function () {",
                  "    pm.expect(doc.documentId).to.eql(expectedDocId);",
                  "});",
                  "",
                  "pm.test('Document state is ACTIVE', function () {",
                  "    pm.expect(doc.state).to.eql('ACTIVE');",
                  "});",
                  "",
                  "pm.test('Cabinet ID is set', function () {",
                  "    pm.expect(doc.cabinetId).to.not.be.empty;",
                  "    pm.expect(doc.cabinetId).to.eql('NG-8RZI6EOH');",
                  "});",
                  "",
                  "pm.test('Document name was updated in Scenario 2', function () {",
                  "    pm.expect(doc.name).to.include('[UPDATED]');",
                  "});",
                  "",
                  "pm.test('EnvUrl is set', function () {",
                  "    pm.expect(doc.envUrl).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ Document Metadata Validation:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document created in Scenario 1 and updated in Scenario 2 exists with correct metadata."
          },
          "response": []
        },
        {
          "name": "Validate Versions",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Version Information');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has versions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.versions).to.be.an('array');",
                  "    pm.expect(doc.versions.length).to.be.at.least(1);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.versions && doc.versions.length > 0) {",
                  "    var version1 = doc.versions[0];",
                  "    ",
                  "    pm.test('Version 1 exists', function () {",
                  "        pm.expect(version1.versionId).to.eql(1);",
                  "    });",
                  "    ",
                  "    pm.test('Version has extension', function () {",
                  "        pm.expect(version1.extension).to.eql('txt');",
                  "    });",
                  "    ",
                  "    pm.test('Version has label', function () {",
                  "        pm.expect(version1.label).to.eql('1.0');",
                  "    });",
                  "    ",
                  "    pm.test('Version state is ACTIVE', function () {",
                  "        pm.expect(version1.state).to.eql('ACTIVE');",
                  "    });",
                  "    ",
                  "    pm.test('Version has created timestamp', function () {",
                  "        pm.expect(version1.created).to.have.property('timestamp');",
                  "        pm.expect(version1.created.timestamp).to.not.be.empty;",
                  "    });",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ Version Validation:');",
                  "    console.log(`   Version ID: ${version1.versionId}`);",
                  "    console.log(`   Label: ${version1.label}`);",
                  "    console.log(`   Extension: ${version1.extension}`);",
                  "    console.log(`   Size: ${version1.size} bytes`);",
                  "    console.log(`   State: ${version1.state}`);",
                  "    console.log(`   Created: ${version1.created.timestamp}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document has the correct version information from the NMD message."
          },
          "response": []
        },
        {
          "name": "Validate ACL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying ACL Configuration');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ACL permissions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.aclPermissions).to.be.an('object');",
                  "    pm.expect(doc.aclPermissions.relationships).to.be.an('array');",
                  "    pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.aclPermissions && doc.aclPermissions.relationships) {",
                  "    pm.test('ACL has expected entries', function () {",
                  "        pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "    });",
                  "    ",
                  "    var groupAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'UG-LGSFSO0I');",
                  "    var userAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'DUCOT-pbs.nonadmin');",
                  "    ",
                  "    pm.test('Group ACL entry exists', function () {",
                  "        pm.expect(groupAcl).to.not.be.undefined;",
                  "        pm.expect(groupAcl.subjectType).to.eql('group');",
                  "    });",
                  "    ",
                  "    pm.test('User ACL entry exists', function () {",
                  "        pm.expect(userAcl).to.not.be.undefined;",
                  "        pm.expect(userAcl.subjectType).to.eql('user');",
                  "    });",
                  "    ",
                  "    pm.test('ACL has correct relationships (VESD)', function () {",
                  "        pm.expect(groupAcl.relationships).to.include('viewer');",
                  "        pm.expect(groupAcl.relationships).to.include('editor');",
                  "        pm.expect(groupAcl.relationships).to.include('sharer');",
                  "        pm.expect(groupAcl.relationships).to.include('administrator');",
                  "    });",
                  "    ",
                  "    // ACL MODIFICATION TESTS (optional - only run if scenario1Message exists)",
                  "    const scenario1Message = pm.environment.get('nmdMessage_scenario1');",
                  "    const scenario2Message = pm.environment.get('nmdMessage_scenario2');",
                  "    ",
                  "    if (scenario1Message && scenario2Message) {",
                  "        const msg1 = JSON.parse(scenario1Message);",
                  "        const msg2 = JSON.parse(scenario2Message);",
                  "        ",
                  "        // Check if this is an ACL modification test",
                  "        if (msg1.documents && msg1.documents['1'].docProps.name.includes('ACL Modification')) {",
                  "            console.log('');",
                  "            console.log('üî¨ ACL MODIFICATION TEST DETECTED');",
                  "            console.log('   Running enhanced ACL validation...');",
                  "            ",
                  "            const initialAcl = msg1.envProps.acl || [];",
                  "            const modifiedAcl = msg2.envProps.acl || [];",
                  "            const actualAcl = doc.aclPermissions.relationships;",
                  "            ",
                  "            pm.test('ACL Modification: Entry count matches modified sample', function () {",
                  "                pm.expect(actualAcl.length).to.equal(modifiedAcl.length);",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New user DUCOT-user2 present', function () {",
                  "                const user2 = actualAcl.find(e => e.subjectId === 'DUCOT-user2');",
                  "                pm.expect(user2).to.not.be.undefined;",
                  "                pm.expect(user2.subjectType).to.eql('user');",
                  "                pm.expect(user2.relationships).to.include('viewer');",
                  "                pm.expect(user2.relationships).to.include('editor');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New group UG-NEWGROUP present', function () {",
                  "                const newGroup = actualAcl.find(e => e.subjectId === 'UG-NEWGROUP');",
                  "                pm.expect(newGroup).to.not.be.undefined;",
                  "                pm.expect(newGroup.subjectType).to.eql('group');",
                  "                pm.expect(newGroup.relationships).to.include('viewer');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: Cabinet NG-8RZI6EOH removed', function () {",
                  "                const cabinet = actualAcl.find(e => e.subjectId === 'NG-8RZI6EOH');",
                  "                pm.expect(cabinet).to.be.undefined;",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: DUCOT-pbs.nonadmin permissions modified (VE only)', function () {",
                  "                const user = actualAcl.find(e => e.subjectId === 'DUCOT-pbs.nonadmin');",
                  "                pm.expect(user).to.not.be.undefined;",
                  "                pm.expect(user.relationships).to.include('viewer');",
                  "                pm.expect(user.relationships).to.include('editor');",
                  "                pm.expect(user.relationships).to.not.include('sharer');",
                  "                pm.expect(user.relationships).to.not.include('administrator');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: UG-LGSFSO0I unchanged (VESD)', function () {",
                  "                const group = actualAcl.find(e => e.subjectId === 'UG-LGSFSO0I');",
                  "                pm.expect(group).to.not.be.undefined;",
                  "                pm.expect(group.relationships).to.include('viewer');",
                  "                pm.expect(group.relationships).to.include('editor');",
                  "                pm.expect(group.relationships).to.include('sharer');",
                  "                pm.expect(group.relationships).to.include('administrator');",
                  "            });",
                  "            ",
                  "            console.log('   ‚úÖ ACL modification validation complete');",
                  "        }",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ ACL Validation:');",
                  "    console.log(`   Object Type: ${doc.aclPermissions.objectType}`);",
                  "    console.log(`   Object ID: ${doc.aclPermissions.objectId}`);",
                  "    console.log(`   Total ACL Entries: ${doc.aclPermissions.relationships.length}`);",
                  "    doc.aclPermissions.relationships.forEach((entry, idx) => {",
                  "        console.log(`   Entry ${idx + 1}:`);",
                  "        console.log(`      Subject: ${entry.subjectId} (${entry.subjectType})`);",
                  "        console.log(`      Relationships: ${entry.relationships.join(', ')}`);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the ACL was correctly transformed from NMD format (VESD) to SpiceDB relations (viewer, editor, sharer, administrator)."
          },
          "response": []
        },
        {
          "name": "Validate ModNums",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Modification Numbers');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ModNums', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.docModNum).to.not.be.null;",
                  "    pm.expect(doc.nameModNum).to.not.be.null;",
                  "    pm.expect(doc.contentModNum).to.not.be.null;",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "pm.test('ModNums are valid ISO 8601 timestamps', function () {",
                  "    var isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;",
                  "    pm.expect(doc.docModNum).to.match(isoRegex);",
                  "    pm.expect(doc.nameModNum).to.match(isoRegex);",
                  "    pm.expect(doc.contentModNum).to.match(isoRegex);",
                  "});",
                  "",
                  "pm.test('Document has modified timestamp', function () {",
                  "    pm.expect(doc.modified).to.have.property('timestamp');",
                  "    pm.expect(doc.modified.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "pm.test('Document has created timestamp', function () {",
                  "    pm.expect(doc.created).to.have.property('timestamp');",
                  "    pm.expect(doc.created.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ ModNum Validation:');",
                  "console.log(`   DocModNum: ${doc.docModNum} (ISO 8601 format)`);",
                  "console.log(`   NameModNum: ${doc.nameModNum}`);",
                  "console.log(`   ContentModNum: ${doc.contentModNum}`);",
                  "console.log(`   Created: ${doc.created.timestamp}`);",
                  "console.log(`   Modified: ${doc.modified.timestamp}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that modification numbers (ModNums) were correctly set and incremented between scenarios."
          },
          "response": []
        },
        {
          "name": "Validation Summary",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üìä FINAL VALIDATION SUMMARY');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var doc = pm.response.json();",
                  "",
                  "console.log('');",
                  "console.log('üéâ ALL VALIDATIONS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã Complete Document State:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   Official Version: ${doc.officialVersion}`);",
                  "console.log(`   Next Version: ${doc.nextVersion}`);",
                  "console.log(`   Versions Count: ${doc.versions ? doc.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${doc.acl ? doc.acl.length : 0}`);",
                  "console.log(`   DocModNum: ${doc.docModNum}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);",
                  "console.log('');",
                  "console.log('‚úÖ Scenario 1 (CREATE): Verified');",
                  "console.log('‚úÖ Scenario 2 (UPDATE): Verified');",
                  "console.log('‚úÖ Data Integrity: Confirmed');",
                  "console.log('');",
                  "console.log('='.repeat(50));",
                  "console.log('‚úÖ POC VALIDATION SUCCESSFUL!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Final validation that prints a comprehensive summary of the document state after both scenarios."
          },
          "response": []
        }
      ]
    },
    {
      "name": "06 - Test Scenario: PDF Document",
      "item": [
        {
          "name": "Step 1: Load PDF Document Sample",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load PDF Document sample",
                  "const sample = pm.environment.get('sample_pdf_document');",
                  "",
                  "if (sample) {",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate dynamic document ID",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ TEST SCENARIO: PDF DOCUMENT');",
                  "    console.log(\"=\".repeat(60));",
                  "    console.log('   PDF file - read-only document type');",
                  "    console.log(`   Document ID: ${newDocId}`);",
                  "    console.log(\"=\".repeat(60));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded\", function () {",
                  "    pm.expect(pm.environment.get(\"nmdMessage\")).to.not.be.empty;",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Extract Content Metadata from NMD",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Extract content-related metadata from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('sample_pdf_document'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const version = doc.versions['1'];",
                  "",
                  "// Extract filename and extension",
                  "const docName = doc.docProps.name;",
                  "const extension = version.verProps.exten;",
                  "const filename = `${docName}.${extension}`;",
                  "",
                  "// Extract user ID and timestamp",
                  "const userId = nmdMessage.envProps.authorguid;",
                  "const createdTimestamp = new Date(parseInt(version.verProps.created.match(/\\d+/)[0])).toISOString();",
                  "",
                  "// Save to environment",
                  "pm.environment.set('contentFilename', filename);",
                  "pm.environment.set('contentExtension', extension);",
                  "pm.environment.set('userId', userId);",
                  "",
                  "console.log('');",
                  "console.log('üìÑ CONTENT METADATA EXTRACTION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üî§ Extension: ${extension}`);",
                  "console.log(`üë§ User ID: ${userId}`);",
                  "console.log(`‚è∞ Created: ${createdTimestamp}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// This is just a setup request, no actual HTTP call needed",
                  "pm.test('Content metadata extracted', function () {",
                  "    const filename = pm.environment.get('contentFilename');",
                  "    const extension = pm.environment.get('contentExtension');",
                  "    const userId = pm.environment.get('userId');",
                  "    ",
                  "    pm.expect(filename).to.not.be.empty;",
                  "    pm.expect(extension).to.not.be.empty;",
                  "    pm.expect(userId).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Content metadata ready for snapshot creation');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Extracts content metadata from NMD message (filename, extension, userId) needed for snapshot creation.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Create Snapshot & Get Presigned URL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('üì∏ CREATING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üåê Requesting presigned URL from Content API...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot created successfully', function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                  "});",
                  "",
                  "const response = pm.response.json();",
                  "",
                  "pm.test('Response contains presigned URL', function () {",
                  "    pm.expect(response.presignedUrl).to.be.a('string');",
                  "    pm.expect(response.presignedUrl).to.include('s3');",
                  "});",
                  "",
                  "// Note: entityId is null initially, gets generated after content upload",
                  "pm.test('Response has entityId field', function () {",
                  "    pm.expect(response).to.have.property('entityId');",
                  "});",
                  "",
                  "// Save presigned URL and object key for later verification",
                  "pm.environment.set('presignedUrl', response.presignedUrl);",
                  "pm.environment.set('snapshotObjectKey', response.objectKey);",
                  "",
                  "console.log('‚úÖ Snapshot created:');",
                  "console.log(`   üì¶ Object Key: ${response.objectKey}`);",
                  "console.log(`   üîó Presigned URL: ${response.presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"contentType\": \"text/plain\",\n  \"filename\": \"{{contentFilename}}\",\n  \"extension\": \"{{contentExtension}}\",\n  \"createdByUserId\": \"{{userId}}\",\n  \"createdTimestamp\": \"{{$isoTimestamp}}\",\n  \"location\": \"poc-test\",\n  \"source\": \"doc-ndserver-sync-wrk-poc\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Creates a snapshot entity in the Content API and retrieves a presigned S3 URL for uploading the document content.\n\nThis corresponds to Phase 1.3 in the integration test."
          },
          "response": []
        },
        {
          "name": "Upload Content to S3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const presignedUrl = pm.environment.get('presignedUrl');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('‚òÅÔ∏è  UPLOADING TO S3');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù File: ${filename}`);",
                  "console.log(`üîó URL: ${presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Content uploaded to S3 successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "console.log('‚úÖ Content uploaded successfully to S3');",
                  "console.log('   üì¶ Document now has both metadata AND content');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/octet-stream"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "This is test content for POC document {{documentId}}.\nCreated at: {{$isoTimestamp}}\nFilename: {{contentFilename}}\n\nThis content was uploaded as part of the doc-ndserver-sync-wrk POC test to verify the complete document lifecycle including content upload to S3."
            },
            "url": {
              "raw": "{{presignedUrl}}",
              "host": [
                "{{presignedUrl}}"
              ]
            },
            "description": "Uploads the document content to S3 using the presigned URL obtained from the Content API.\n\nThis corresponds to Phase 1.4 in the integration test."
          },
          "response": []
        },
        {
          "name": "Verify Snapshot Exists",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const snapshotId = pm.environment.get('snapshotId');",
                  "",
                  "console.log('');",
                  "console.log('üîç VERIFYING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìã Snapshot ID: ${snapshotId}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot retrieved successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "const snapshotResponse = pm.response.json();",
                  "const snapshots = snapshotResponse.results || snapshotResponse;",
                  "const objectKey = pm.environment.get('snapshotObjectKey');",
                  "const expectedExtension = pm.environment.get('contentExtension');",
                  "",
                  "pm.test('Snapshot list contains snapshots', function () {",
                  "    pm.expect(snapshots).to.be.an('array');",
                  "    pm.expect(snapshots.length).to.be.at.least(1);",
                  "});",
                  "",
                  "// Find snapshot by objectKey since entityId is generated after upload",
                  "const createdSnapshot = snapshots.find(s => s.objectKey === objectKey);",
                  "",
                  "pm.test('Created snapshot found in list', function () {",
                  "    pm.expect(createdSnapshot).to.not.be.undefined;",
                  "});",
                  "",
                  "pm.test('Snapshot has correct extension', function () {",
                  "    pm.expect(createdSnapshot.extension).to.equal(expectedExtension);",
                  "});",
                  "",
                  "pm.test('Snapshot has content uploaded', function () {",
                  "    pm.expect(createdSnapshot.length).to.be.above(0);",
                  "});",
                  "",
                  "console.log('‚úÖ Snapshot verified:');",
                  "console.log(`   üìã Entity ID: ${createdSnapshot.entityId}`);",
                  "console.log(`   üî§ Extension: ${createdSnapshot.extension}`);",
                  "console.log(`   üì¶ Size: ${createdSnapshot.length} bytes`);",
                  "console.log(`   ‚úîÔ∏è  Content upload complete!`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Verifies that the snapshot was successfully created and contains the uploaded content."
          },
          "response": []
        },
        {
          "name": "S1 - Step 1: Check Document Existence (Expect 404)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "pm.environment.set('nmdMessage', pm.environment.get('nmdMessage_scenario1'));",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 1: NEW DOCUMENT CREATION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 404 (document doesn't exist)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(404);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'true');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document not found (404)');",
                  "console.log('   Ready to CREATE new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Checks if the document already exists in the metadata API.\n\nExpected for POC: 404 Not Found (new document)"
          },
          "response": []
        },
        {
          "name": "S1 - Step 2: Configure Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Build documentRoot from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "",
                  "// Format: [\"NG-CABID/documents\"]",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "",
                  "console.log(`üìÅ Configuring content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 204 (content root set)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root configured for new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            },
            "description": "Updates the content service metadata to set the document root location.\n\nThis configures where content files are stored in S3."
          },
          "response": []
        },
        {
          "name": "S1 - Step 3: Build CREATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === MINIMAL TRANSFORMATION FOR POC ===",
                  "// This is a simplified version for new document creation only",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "// Helper: Convert NetDocuments date format",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "// Helper: Build ACL",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = {",
                  "        'V': 'viewer',",
                  "        'E': 'editor',",
                  "        'S': 'sharer',",
                  "        'D': 'administrator',",
                  "        'Z': 'default'",
                  "    };",
                  "    ",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        ",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        ",
                  "        return {",
                  "            SubjectType: subjectType,",
                  "            SubjectId: entry.guid,",
                  "            Relations: relations",
                  "        };",
                  "    });",
                  "}",
                  "",
                  "// Helper: Build versions list",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    ",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        ",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: {",
                  "                UserId: props.creatorguid,",
                  "                Timestamp: convertDate(props.created)",
                  "            },",
                  "            Modified: {",
                  "                UserId: props.modifiedByGuid || props.creatorguid,",
                  "                Timestamp: convertDate(props.modified || props.created)",
                  "            },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    ",
                  "    return versionsList;",
                  "}",
                  "",
                  "// Build minimal patch request for NEW document",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: docProps.name,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum),",
                  "    NameModNum: parseInt(docProps.nameModNum),",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: {",
                  "        UserId: envProps.authorguid,",
                  "        Timestamp: convertDate(envProps.created)",
                  "    },",
                  "    Modified: {",
                  "        UserId: envProps['modified by guid'],",
                  "        Timestamp: convertDate(envProps.modified)",
                  "    },",
                  "    CheckedOut: {",
                  "        UserId: null,",
                  "        Timestamp: null,",
                  "        Comment: null,",
                  "        CollaborationEdit: null,",
                  "        CollaborationEditType: null",
                  "    },",
                  "    Locked: {",
                  "        UserId: null,",
                  "        Comment: null,",
                  "        Timestamp: null",
                  "    },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "",
                  "console.log('‚úÖ CREATE patch request built');",
                  "console.log(`   Document: ${patchRequest.Name}`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to CREATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Builds the patch request by transforming the NMD message.\n\nThis is a dummy request that only runs the pre-request script to build the patchRequest variable.\n\nFor POC: Simplified transformation for new document creation only."
          },
          "response": []
        },
        {
          "name": "S1 - Step 4: CREATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üöÄ CREATING new document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Document created successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "",
                  "// Store created document for Scenario 2",
                  "pm.environment.set('scenario1_created_document', JSON.stringify(response));",
                  "pm.environment.set('scenario1_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 1 COMPLETE: Document CREATED');",
                  "console.log('üìä Created Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Cabinet ID: ${response.cabinetId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${response.acl ? response.acl.length : 0}`);",
                  "console.log('');",
                  "console.log('‚û°Ô∏è  Document ready for Scenario 2 (UPDATE)');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Creates/updates the document in the metadata API.\n\nFor POC: Creates a new document with metadata, versions, and ACLs.\n\nThis is the main synchronization call."
          },
          "response": []
        },
        {
          "name": "S2 - Step 1: Check Document Existence (Expect 200)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 2: DOCUMENT UPDATE');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists (should be 200)...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 200 (document exists)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var extendedDoc = pm.response.json();",
                  "pm.environment.set('existingDocument', JSON.stringify(extendedDoc));",
                  "pm.environment.set('scenario2_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'false');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document found (200 OK)');",
                  "console.log(`   Document State: ${extendedDoc.state}`);",
                  "console.log(`   Current Versions: ${extendedDoc.versions ? extendedDoc.versions.length : 0}`);",
                  "console.log('   Ready to UPDATE existing document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 2: Update Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "console.log(`üìÅ Updating content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 204 (content root updated)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario2_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root updated');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 3: Build UPDATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === BUILD PATCH REQUEST FOR UPDATING DOCUMENT ===",
                  "// This simulates a change: update document name with timestamp",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = { 'V': 'viewer', 'E': 'editor', 'S': 'sharer', 'D': 'administrator', 'Z': 'default' };",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        return { SubjectType: subjectType, SubjectId: entry.guid, Relations: relations };",
                  "    });",
                  "}",
                  "",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: { UserId: props.creatorguid, Timestamp: convertDate(props.created) },",
                  "            Modified: { UserId: props.modifiedByGuid || props.creatorguid, Timestamp: convertDate(props.modified || props.created) },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    return versionsList;",
                  "}",
                  "",
                  "// SIMULATE A CHANGE: Update document name",
                  "const updatedName = docProps.name + ' [UPDATED]';",
                  "const now = new Date().toISOString();",
                  "",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: updatedName,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum) + 1,",
                  "    NameModNum: parseInt(docProps.nameModNum) + 1,",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: { UserId: envProps.authorguid, Timestamp: convertDate(envProps.created) },",
                  "    Modified: { UserId: envProps['modified by guid'], Timestamp: now },",
                  "    CheckedOut: { UserId: null, Timestamp: null, Comment: null, CollaborationEdit: null, CollaborationEditType: null },",
                  "    Locked: { UserId: null, Comment: null, Timestamp: null },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "console.log('‚úÖ UPDATE patch request built');",
                  "console.log(`   CHANGE: Name updated to: ${updatedName}`);",
                  "console.log(`   CHANGE: Modified timestamp: ${now}`);",
                  "console.log(`   CHANGE: DocModNum incremented`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to UPDATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 4: UPDATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üîÑ UPDATING existing document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Document updated successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "pm.environment.set('scenario2_updated_document', JSON.stringify(response));",
                  "pm.environment.set('scenario2_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 2 COMPLETE: Document UPDATED');",
                  "console.log('üìä Updated Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log('');",
                  "console.log('üéâ BOTH SCENARIOS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã SUMMARY:');",
                  "console.log(`   Scenario 1 - Step 1: ${pm.environment.get('scenario1_step1_status')} (Expected: 404)`);",
                  "console.log(`   Scenario 1 - Step 4: ${pm.environment.get('scenario1_step4_status')} (Expected: 200 - CREATE)`);",
                  "console.log(`   Scenario 2 - Step 1: ${pm.environment.get('scenario2_step1_status')} (Expected: 200 - EXISTS)`);",
                  "console.log(`   Scenario 2 - Step 4: ${pm.environment.get('scenario2_step4_status')} (Expected: 200 - UPDATE)`);",
                  "console.log('');",
                  "console.log('‚úÖ POC validated BOTH workflows successfully!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Validate Document Metadata",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Document Metadata');",
                  "console.log('='.repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get('documentId')}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document exists (200 OK)', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "var expectedDocId = pm.environment.get('documentId');",
                  "",
                  "pm.test('Document ID matches', function () {",
                  "    pm.expect(doc.documentId).to.eql(expectedDocId);",
                  "});",
                  "",
                  "pm.test('Document state is ACTIVE', function () {",
                  "    pm.expect(doc.state).to.eql('ACTIVE');",
                  "});",
                  "",
                  "pm.test('Cabinet ID is set', function () {",
                  "    pm.expect(doc.cabinetId).to.not.be.empty;",
                  "    pm.expect(doc.cabinetId).to.eql('NG-8RZI6EOH');",
                  "});",
                  "",
                  "pm.test('Document name was updated in Scenario 2', function () {",
                  "    pm.expect(doc.name).to.include('[UPDATED]');",
                  "});",
                  "",
                  "pm.test('EnvUrl is set', function () {",
                  "    pm.expect(doc.envUrl).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ Document Metadata Validation:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document created in Scenario 1 and updated in Scenario 2 exists with correct metadata."
          },
          "response": []
        },
        {
          "name": "Validate Versions",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Version Information');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has versions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.versions).to.be.an('array');",
                  "    pm.expect(doc.versions.length).to.be.at.least(1);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.versions && doc.versions.length > 0) {",
                  "    var version1 = doc.versions[0];",
                  "    ",
                  "    pm.test('Version 1 exists', function () {",
                  "        pm.expect(version1.versionId).to.eql(1);",
                  "    });",
                  "    ",
                  "    pm.test('Version has extension', function () {",
                  "        pm.expect(version1.extension).to.eql('txt');",
                  "    });",
                  "    ",
                  "    pm.test('Version has label', function () {",
                  "        pm.expect(version1.label).to.eql('1.0');",
                  "    });",
                  "    ",
                  "    pm.test('Version state is ACTIVE', function () {",
                  "        pm.expect(version1.state).to.eql('ACTIVE');",
                  "    });",
                  "    ",
                  "    pm.test('Version has created timestamp', function () {",
                  "        pm.expect(version1.created).to.have.property('timestamp');",
                  "        pm.expect(version1.created.timestamp).to.not.be.empty;",
                  "    });",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ Version Validation:');",
                  "    console.log(`   Version ID: ${version1.versionId}`);",
                  "    console.log(`   Label: ${version1.label}`);",
                  "    console.log(`   Extension: ${version1.extension}`);",
                  "    console.log(`   Size: ${version1.size} bytes`);",
                  "    console.log(`   State: ${version1.state}`);",
                  "    console.log(`   Created: ${version1.created.timestamp}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document has the correct version information from the NMD message."
          },
          "response": []
        },
        {
          "name": "Validate ACL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying ACL Configuration');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ACL permissions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.aclPermissions).to.be.an('object');",
                  "    pm.expect(doc.aclPermissions.relationships).to.be.an('array');",
                  "    pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.aclPermissions && doc.aclPermissions.relationships) {",
                  "    pm.test('ACL has expected entries', function () {",
                  "        pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "    });",
                  "    ",
                  "    var groupAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'UG-LGSFSO0I');",
                  "    var userAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'DUCOT-pbs.nonadmin');",
                  "    ",
                  "    pm.test('Group ACL entry exists', function () {",
                  "        pm.expect(groupAcl).to.not.be.undefined;",
                  "        pm.expect(groupAcl.subjectType).to.eql('group');",
                  "    });",
                  "    ",
                  "    pm.test('User ACL entry exists', function () {",
                  "        pm.expect(userAcl).to.not.be.undefined;",
                  "        pm.expect(userAcl.subjectType).to.eql('user');",
                  "    });",
                  "    ",
                  "    pm.test('ACL has correct relationships (VESD)', function () {",
                  "        pm.expect(groupAcl.relationships).to.include('viewer');",
                  "        pm.expect(groupAcl.relationships).to.include('editor');",
                  "        pm.expect(groupAcl.relationships).to.include('sharer');",
                  "        pm.expect(groupAcl.relationships).to.include('administrator');",
                  "    });",
                  "    ",
                  "    // ACL MODIFICATION TESTS (optional - only run if scenario1Message exists)",
                  "    const scenario1Message = pm.environment.get('nmdMessage_scenario1');",
                  "    const scenario2Message = pm.environment.get('nmdMessage_scenario2');",
                  "    ",
                  "    if (scenario1Message && scenario2Message) {",
                  "        const msg1 = JSON.parse(scenario1Message);",
                  "        const msg2 = JSON.parse(scenario2Message);",
                  "        ",
                  "        // Check if this is an ACL modification test",
                  "        if (msg1.documents && msg1.documents['1'].docProps.name.includes('ACL Modification')) {",
                  "            console.log('');",
                  "            console.log('üî¨ ACL MODIFICATION TEST DETECTED');",
                  "            console.log('   Running enhanced ACL validation...');",
                  "            ",
                  "            const initialAcl = msg1.envProps.acl || [];",
                  "            const modifiedAcl = msg2.envProps.acl || [];",
                  "            const actualAcl = doc.aclPermissions.relationships;",
                  "            ",
                  "            pm.test('ACL Modification: Entry count matches modified sample', function () {",
                  "                pm.expect(actualAcl.length).to.equal(modifiedAcl.length);",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New user DUCOT-user2 present', function () {",
                  "                const user2 = actualAcl.find(e => e.subjectId === 'DUCOT-user2');",
                  "                pm.expect(user2).to.not.be.undefined;",
                  "                pm.expect(user2.subjectType).to.eql('user');",
                  "                pm.expect(user2.relationships).to.include('viewer');",
                  "                pm.expect(user2.relationships).to.include('editor');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New group UG-NEWGROUP present', function () {",
                  "                const newGroup = actualAcl.find(e => e.subjectId === 'UG-NEWGROUP');",
                  "                pm.expect(newGroup).to.not.be.undefined;",
                  "                pm.expect(newGroup.subjectType).to.eql('group');",
                  "                pm.expect(newGroup.relationships).to.include('viewer');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: Cabinet NG-8RZI6EOH removed', function () {",
                  "                const cabinet = actualAcl.find(e => e.subjectId === 'NG-8RZI6EOH');",
                  "                pm.expect(cabinet).to.be.undefined;",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: DUCOT-pbs.nonadmin permissions modified (VE only)', function () {",
                  "                const user = actualAcl.find(e => e.subjectId === 'DUCOT-pbs.nonadmin');",
                  "                pm.expect(user).to.not.be.undefined;",
                  "                pm.expect(user.relationships).to.include('viewer');",
                  "                pm.expect(user.relationships).to.include('editor');",
                  "                pm.expect(user.relationships).to.not.include('sharer');",
                  "                pm.expect(user.relationships).to.not.include('administrator');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: UG-LGSFSO0I unchanged (VESD)', function () {",
                  "                const group = actualAcl.find(e => e.subjectId === 'UG-LGSFSO0I');",
                  "                pm.expect(group).to.not.be.undefined;",
                  "                pm.expect(group.relationships).to.include('viewer');",
                  "                pm.expect(group.relationships).to.include('editor');",
                  "                pm.expect(group.relationships).to.include('sharer');",
                  "                pm.expect(group.relationships).to.include('administrator');",
                  "            });",
                  "            ",
                  "            console.log('   ‚úÖ ACL modification validation complete');",
                  "        }",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ ACL Validation:');",
                  "    console.log(`   Object Type: ${doc.aclPermissions.objectType}`);",
                  "    console.log(`   Object ID: ${doc.aclPermissions.objectId}`);",
                  "    console.log(`   Total ACL Entries: ${doc.aclPermissions.relationships.length}`);",
                  "    doc.aclPermissions.relationships.forEach((entry, idx) => {",
                  "        console.log(`   Entry ${idx + 1}:`);",
                  "        console.log(`      Subject: ${entry.subjectId} (${entry.subjectType})`);",
                  "        console.log(`      Relationships: ${entry.relationships.join(', ')}`);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the ACL was correctly transformed from NMD format (VESD) to SpiceDB relations (viewer, editor, sharer, administrator)."
          },
          "response": []
        },
        {
          "name": "Validate ModNums",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Modification Numbers');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ModNums', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.docModNum).to.not.be.null;",
                  "    pm.expect(doc.nameModNum).to.not.be.null;",
                  "    pm.expect(doc.contentModNum).to.not.be.null;",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "pm.test('ModNums are valid ISO 8601 timestamps', function () {",
                  "    var isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;",
                  "    pm.expect(doc.docModNum).to.match(isoRegex);",
                  "    pm.expect(doc.nameModNum).to.match(isoRegex);",
                  "    pm.expect(doc.contentModNum).to.match(isoRegex);",
                  "});",
                  "",
                  "pm.test('Document has modified timestamp', function () {",
                  "    pm.expect(doc.modified).to.have.property('timestamp');",
                  "    pm.expect(doc.modified.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "pm.test('Document has created timestamp', function () {",
                  "    pm.expect(doc.created).to.have.property('timestamp');",
                  "    pm.expect(doc.created.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ ModNum Validation:');",
                  "console.log(`   DocModNum: ${doc.docModNum} (ISO 8601 format)`);",
                  "console.log(`   NameModNum: ${doc.nameModNum}`);",
                  "console.log(`   ContentModNum: ${doc.contentModNum}`);",
                  "console.log(`   Created: ${doc.created.timestamp}`);",
                  "console.log(`   Modified: ${doc.modified.timestamp}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that modification numbers (ModNums) were correctly set and incremented between scenarios."
          },
          "response": []
        },
        {
          "name": "Validation Summary",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üìä FINAL VALIDATION SUMMARY');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var doc = pm.response.json();",
                  "",
                  "console.log('');",
                  "console.log('üéâ ALL VALIDATIONS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã Complete Document State:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   Official Version: ${doc.officialVersion}`);",
                  "console.log(`   Next Version: ${doc.nextVersion}`);",
                  "console.log(`   Versions Count: ${doc.versions ? doc.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${doc.acl ? doc.acl.length : 0}`);",
                  "console.log(`   DocModNum: ${doc.docModNum}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);",
                  "console.log('');",
                  "console.log('‚úÖ Scenario 1 (CREATE): Verified');",
                  "console.log('‚úÖ Scenario 2 (UPDATE): Verified');",
                  "console.log('‚úÖ Data Integrity: Confirmed');",
                  "console.log('');",
                  "console.log('='.repeat(50));",
                  "console.log('‚úÖ POC VALIDATION SUCCESSFUL!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Final validation that prints a comprehensive summary of the document state after both scenarios."
          },
          "response": []
        }
      ]
    },
    {
      "name": "07 - Test Scenario: Folder Document",
      "item": [
        {
          "name": "Step 1: Load Folder Container Sample",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load Folder Container sample",
                  "const sample = pm.environment.get('sample_folder_document');",
                  "",
                  "if (sample) {",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate dynamic document ID",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ TEST SCENARIO: FOLDER CONTAINER');",
                  "    console.log(\"=\".repeat(60));",
                  "    console.log('   Folder container (.ndfld) - 8% of production');",
                  "    console.log('   ‚ö†Ô∏è Note: This is a folder container, not a file');",
                  "    console.log(`   Document ID: ${newDocId}`);",
                  "    console.log(\"=\".repeat(60));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded\", function () {",
                  "    pm.expect(pm.environment.get(\"nmdMessage\")).to.not.be.empty;",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Extract Content Metadata from NMD",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Extract content-related metadata from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('sample_folder_document'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const version = doc.versions['1'];",
                  "",
                  "// Extract filename and extension",
                  "const docName = doc.docProps.name;",
                  "const extension = version.verProps.exten;",
                  "const filename = `${docName}.${extension}`;",
                  "",
                  "// Extract user ID and timestamp",
                  "const userId = nmdMessage.envProps.authorguid;",
                  "const createdTimestamp = new Date(parseInt(version.verProps.created.match(/\\d+/)[0])).toISOString();",
                  "",
                  "// Save to environment",
                  "pm.environment.set('contentFilename', filename);",
                  "pm.environment.set('contentExtension', extension);",
                  "pm.environment.set('userId', userId);",
                  "",
                  "console.log('');",
                  "console.log('üìÑ CONTENT METADATA EXTRACTION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üî§ Extension: ${extension}`);",
                  "console.log(`üë§ User ID: ${userId}`);",
                  "console.log(`‚è∞ Created: ${createdTimestamp}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// This is just a setup request, no actual HTTP call needed",
                  "pm.test('Content metadata extracted', function () {",
                  "    const filename = pm.environment.get('contentFilename');",
                  "    const extension = pm.environment.get('contentExtension');",
                  "    const userId = pm.environment.get('userId');",
                  "    ",
                  "    pm.expect(filename).to.not.be.empty;",
                  "    pm.expect(extension).to.not.be.empty;",
                  "    pm.expect(userId).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Content metadata ready for snapshot creation');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Extracts content metadata from NMD message (filename, extension, userId) needed for snapshot creation.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Create Snapshot & Get Presigned URL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('üì∏ CREATING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üåê Requesting presigned URL from Content API...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot created successfully', function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                  "});",
                  "",
                  "const response = pm.response.json();",
                  "",
                  "pm.test('Response contains presigned URL', function () {",
                  "    pm.expect(response.presignedUrl).to.be.a('string');",
                  "    pm.expect(response.presignedUrl).to.include('s3');",
                  "});",
                  "",
                  "// Note: entityId is null initially, gets generated after content upload",
                  "pm.test('Response has entityId field', function () {",
                  "    pm.expect(response).to.have.property('entityId');",
                  "});",
                  "",
                  "// Save presigned URL and object key for later verification",
                  "pm.environment.set('presignedUrl', response.presignedUrl);",
                  "pm.environment.set('snapshotObjectKey', response.objectKey);",
                  "",
                  "console.log('‚úÖ Snapshot created:');",
                  "console.log(`   üì¶ Object Key: ${response.objectKey}`);",
                  "console.log(`   üîó Presigned URL: ${response.presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"contentType\": \"text/plain\",\n  \"filename\": \"{{contentFilename}}\",\n  \"extension\": \"{{contentExtension}}\",\n  \"createdByUserId\": \"{{userId}}\",\n  \"createdTimestamp\": \"{{$isoTimestamp}}\",\n  \"location\": \"poc-test\",\n  \"source\": \"doc-ndserver-sync-wrk-poc\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Creates a snapshot entity in the Content API and retrieves a presigned S3 URL for uploading the document content.\n\nThis corresponds to Phase 1.3 in the integration test."
          },
          "response": []
        },
        {
          "name": "Upload Content to S3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const presignedUrl = pm.environment.get('presignedUrl');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('‚òÅÔ∏è  UPLOADING TO S3');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù File: ${filename}`);",
                  "console.log(`üîó URL: ${presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Content uploaded to S3 successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "console.log('‚úÖ Content uploaded successfully to S3');",
                  "console.log('   üì¶ Document now has both metadata AND content');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/octet-stream"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "This is test content for POC document {{documentId}}.\nCreated at: {{$isoTimestamp}}\nFilename: {{contentFilename}}\n\nThis content was uploaded as part of the doc-ndserver-sync-wrk POC test to verify the complete document lifecycle including content upload to S3."
            },
            "url": {
              "raw": "{{presignedUrl}}",
              "host": [
                "{{presignedUrl}}"
              ]
            },
            "description": "Uploads the document content to S3 using the presigned URL obtained from the Content API.\n\nThis corresponds to Phase 1.4 in the integration test."
          },
          "response": []
        },
        {
          "name": "Verify Snapshot Exists",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const snapshotId = pm.environment.get('snapshotId');",
                  "",
                  "console.log('');",
                  "console.log('üîç VERIFYING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìã Snapshot ID: ${snapshotId}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot retrieved successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "const snapshotResponse = pm.response.json();",
                  "const snapshots = snapshotResponse.results || snapshotResponse;",
                  "const objectKey = pm.environment.get('snapshotObjectKey');",
                  "const expectedExtension = pm.environment.get('contentExtension');",
                  "",
                  "pm.test('Snapshot list contains snapshots', function () {",
                  "    pm.expect(snapshots).to.be.an('array');",
                  "    pm.expect(snapshots.length).to.be.at.least(1);",
                  "});",
                  "",
                  "// Find snapshot by objectKey since entityId is generated after upload",
                  "const createdSnapshot = snapshots.find(s => s.objectKey === objectKey);",
                  "",
                  "pm.test('Created snapshot found in list', function () {",
                  "    pm.expect(createdSnapshot).to.not.be.undefined;",
                  "});",
                  "",
                  "pm.test('Snapshot has correct extension', function () {",
                  "    pm.expect(createdSnapshot.extension).to.equal(expectedExtension);",
                  "});",
                  "",
                  "pm.test('Snapshot has content uploaded', function () {",
                  "    pm.expect(createdSnapshot.length).to.be.above(0);",
                  "});",
                  "",
                  "console.log('‚úÖ Snapshot verified:');",
                  "console.log(`   üìã Entity ID: ${createdSnapshot.entityId}`);",
                  "console.log(`   üî§ Extension: ${createdSnapshot.extension}`);",
                  "console.log(`   üì¶ Size: ${createdSnapshot.length} bytes`);",
                  "console.log(`   ‚úîÔ∏è  Content upload complete!`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Verifies that the snapshot was successfully created and contains the uploaded content."
          },
          "response": []
        },
        {
          "name": "S1 - Step 1: Check Document Existence (Expect 404)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "pm.environment.set('nmdMessage', pm.environment.get('nmdMessage_scenario1'));",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 1: NEW DOCUMENT CREATION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 404 (document doesn't exist)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(404);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'true');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document not found (404)');",
                  "console.log('   Ready to CREATE new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Checks if the document already exists in the metadata API.\n\nExpected for POC: 404 Not Found (new document)"
          },
          "response": []
        },
        {
          "name": "S1 - Step 2: Configure Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Build documentRoot from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "",
                  "// Format: [\"NG-CABID/documents\"]",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "",
                  "console.log(`üìÅ Configuring content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 204 (content root set)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root configured for new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            },
            "description": "Updates the content service metadata to set the document root location.\n\nThis configures where content files are stored in S3."
          },
          "response": []
        },
        {
          "name": "S1 - Step 3: Build CREATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === MINIMAL TRANSFORMATION FOR POC ===",
                  "// This is a simplified version for new document creation only",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "// Helper: Convert NetDocuments date format",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "// Helper: Build ACL",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = {",
                  "        'V': 'viewer',",
                  "        'E': 'editor',",
                  "        'S': 'sharer',",
                  "        'D': 'administrator',",
                  "        'Z': 'default'",
                  "    };",
                  "    ",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        ",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        ",
                  "        return {",
                  "            SubjectType: subjectType,",
                  "            SubjectId: entry.guid,",
                  "            Relations: relations",
                  "        };",
                  "    });",
                  "}",
                  "",
                  "// Helper: Build versions list",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    ",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        ",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: {",
                  "                UserId: props.creatorguid,",
                  "                Timestamp: convertDate(props.created)",
                  "            },",
                  "            Modified: {",
                  "                UserId: props.modifiedByGuid || props.creatorguid,",
                  "                Timestamp: convertDate(props.modified || props.created)",
                  "            },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    ",
                  "    return versionsList;",
                  "}",
                  "",
                  "// Build minimal patch request for NEW document",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: docProps.name,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum),",
                  "    NameModNum: parseInt(docProps.nameModNum),",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: {",
                  "        UserId: envProps.authorguid,",
                  "        Timestamp: convertDate(envProps.created)",
                  "    },",
                  "    Modified: {",
                  "        UserId: envProps['modified by guid'],",
                  "        Timestamp: convertDate(envProps.modified)",
                  "    },",
                  "    CheckedOut: {",
                  "        UserId: null,",
                  "        Timestamp: null,",
                  "        Comment: null,",
                  "        CollaborationEdit: null,",
                  "        CollaborationEditType: null",
                  "    },",
                  "    Locked: {",
                  "        UserId: null,",
                  "        Comment: null,",
                  "        Timestamp: null",
                  "    },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "",
                  "console.log('‚úÖ CREATE patch request built');",
                  "console.log(`   Document: ${patchRequest.Name}`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to CREATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Builds the patch request by transforming the NMD message.\n\nThis is a dummy request that only runs the pre-request script to build the patchRequest variable.\n\nFor POC: Simplified transformation for new document creation only."
          },
          "response": []
        },
        {
          "name": "S1 - Step 4: CREATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üöÄ CREATING new document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Document created successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "",
                  "// Store created document for Scenario 2",
                  "pm.environment.set('scenario1_created_document', JSON.stringify(response));",
                  "pm.environment.set('scenario1_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 1 COMPLETE: Document CREATED');",
                  "console.log('üìä Created Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Cabinet ID: ${response.cabinetId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${response.acl ? response.acl.length : 0}`);",
                  "console.log('');",
                  "console.log('‚û°Ô∏è  Document ready for Scenario 2 (UPDATE)');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Creates/updates the document in the metadata API.\n\nFor POC: Creates a new document with metadata, versions, and ACLs.\n\nThis is the main synchronization call."
          },
          "response": []
        },
        {
          "name": "S2 - Step 1: Check Document Existence (Expect 200)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 2: DOCUMENT UPDATE');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists (should be 200)...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 200 (document exists)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var extendedDoc = pm.response.json();",
                  "pm.environment.set('existingDocument', JSON.stringify(extendedDoc));",
                  "pm.environment.set('scenario2_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'false');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document found (200 OK)');",
                  "console.log(`   Document State: ${extendedDoc.state}`);",
                  "console.log(`   Current Versions: ${extendedDoc.versions ? extendedDoc.versions.length : 0}`);",
                  "console.log('   Ready to UPDATE existing document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 2: Update Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "console.log(`üìÅ Updating content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 204 (content root updated)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario2_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root updated');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 3: Build UPDATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === BUILD PATCH REQUEST FOR UPDATING DOCUMENT ===",
                  "// This simulates a change: update document name with timestamp",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = { 'V': 'viewer', 'E': 'editor', 'S': 'sharer', 'D': 'administrator', 'Z': 'default' };",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        return { SubjectType: subjectType, SubjectId: entry.guid, Relations: relations };",
                  "    });",
                  "}",
                  "",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: { UserId: props.creatorguid, Timestamp: convertDate(props.created) },",
                  "            Modified: { UserId: props.modifiedByGuid || props.creatorguid, Timestamp: convertDate(props.modified || props.created) },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    return versionsList;",
                  "}",
                  "",
                  "// SIMULATE A CHANGE: Update document name",
                  "const updatedName = docProps.name + ' [UPDATED]';",
                  "const now = new Date().toISOString();",
                  "",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: updatedName,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum) + 1,",
                  "    NameModNum: parseInt(docProps.nameModNum) + 1,",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: { UserId: envProps.authorguid, Timestamp: convertDate(envProps.created) },",
                  "    Modified: { UserId: envProps['modified by guid'], Timestamp: now },",
                  "    CheckedOut: { UserId: null, Timestamp: null, Comment: null, CollaborationEdit: null, CollaborationEditType: null },",
                  "    Locked: { UserId: null, Comment: null, Timestamp: null },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "console.log('‚úÖ UPDATE patch request built');",
                  "console.log(`   CHANGE: Name updated to: ${updatedName}`);",
                  "console.log(`   CHANGE: Modified timestamp: ${now}`);",
                  "console.log(`   CHANGE: DocModNum incremented`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to UPDATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 4: UPDATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üîÑ UPDATING existing document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Document updated successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "pm.environment.set('scenario2_updated_document', JSON.stringify(response));",
                  "pm.environment.set('scenario2_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 2 COMPLETE: Document UPDATED');",
                  "console.log('üìä Updated Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log('');",
                  "console.log('üéâ BOTH SCENARIOS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã SUMMARY:');",
                  "console.log(`   Scenario 1 - Step 1: ${pm.environment.get('scenario1_step1_status')} (Expected: 404)`);",
                  "console.log(`   Scenario 1 - Step 4: ${pm.environment.get('scenario1_step4_status')} (Expected: 200 - CREATE)`);",
                  "console.log(`   Scenario 2 - Step 1: ${pm.environment.get('scenario2_step1_status')} (Expected: 200 - EXISTS)`);",
                  "console.log(`   Scenario 2 - Step 4: ${pm.environment.get('scenario2_step4_status')} (Expected: 200 - UPDATE)`);",
                  "console.log('');",
                  "console.log('‚úÖ POC validated BOTH workflows successfully!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Validate Document Metadata",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Document Metadata');",
                  "console.log('='.repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get('documentId')}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document exists (200 OK)', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "var expectedDocId = pm.environment.get('documentId');",
                  "",
                  "pm.test('Document ID matches', function () {",
                  "    pm.expect(doc.documentId).to.eql(expectedDocId);",
                  "});",
                  "",
                  "pm.test('Document state is ACTIVE', function () {",
                  "    pm.expect(doc.state).to.eql('ACTIVE');",
                  "});",
                  "",
                  "pm.test('Cabinet ID is set', function () {",
                  "    pm.expect(doc.cabinetId).to.not.be.empty;",
                  "    pm.expect(doc.cabinetId).to.eql('NG-8RZI6EOH');",
                  "});",
                  "",
                  "pm.test('Document name was updated in Scenario 2', function () {",
                  "    pm.expect(doc.name).to.include('[UPDATED]');",
                  "});",
                  "",
                  "pm.test('EnvUrl is set', function () {",
                  "    pm.expect(doc.envUrl).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ Document Metadata Validation:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document created in Scenario 1 and updated in Scenario 2 exists with correct metadata."
          },
          "response": []
        },
        {
          "name": "Validate Versions",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Version Information');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has versions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.versions).to.be.an('array');",
                  "    pm.expect(doc.versions.length).to.be.at.least(1);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.versions && doc.versions.length > 0) {",
                  "    var version1 = doc.versions[0];",
                  "    ",
                  "    pm.test('Version 1 exists', function () {",
                  "        pm.expect(version1.versionId).to.eql(1);",
                  "    });",
                  "    ",
                  "    pm.test('Version has extension', function () {",
                  "        pm.expect(version1.extension).to.eql('txt');",
                  "    });",
                  "    ",
                  "    pm.test('Version has label', function () {",
                  "        pm.expect(version1.label).to.eql('1.0');",
                  "    });",
                  "    ",
                  "    pm.test('Version state is ACTIVE', function () {",
                  "        pm.expect(version1.state).to.eql('ACTIVE');",
                  "    });",
                  "    ",
                  "    pm.test('Version has created timestamp', function () {",
                  "        pm.expect(version1.created).to.have.property('timestamp');",
                  "        pm.expect(version1.created.timestamp).to.not.be.empty;",
                  "    });",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ Version Validation:');",
                  "    console.log(`   Version ID: ${version1.versionId}`);",
                  "    console.log(`   Label: ${version1.label}`);",
                  "    console.log(`   Extension: ${version1.extension}`);",
                  "    console.log(`   Size: ${version1.size} bytes`);",
                  "    console.log(`   State: ${version1.state}`);",
                  "    console.log(`   Created: ${version1.created.timestamp}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document has the correct version information from the NMD message."
          },
          "response": []
        },
        {
          "name": "Validate ACL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying ACL Configuration');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ACL permissions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.aclPermissions).to.be.an('object');",
                  "    pm.expect(doc.aclPermissions.relationships).to.be.an('array');",
                  "    pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.aclPermissions && doc.aclPermissions.relationships) {",
                  "    pm.test('ACL has expected entries', function () {",
                  "        pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "    });",
                  "    ",
                  "    var groupAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'UG-LGSFSO0I');",
                  "    var userAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'DUCOT-pbs.nonadmin');",
                  "    ",
                  "    pm.test('Group ACL entry exists', function () {",
                  "        pm.expect(groupAcl).to.not.be.undefined;",
                  "        pm.expect(groupAcl.subjectType).to.eql('group');",
                  "    });",
                  "    ",
                  "    pm.test('User ACL entry exists', function () {",
                  "        pm.expect(userAcl).to.not.be.undefined;",
                  "        pm.expect(userAcl.subjectType).to.eql('user');",
                  "    });",
                  "    ",
                  "    pm.test('ACL has correct relationships (VESD)', function () {",
                  "        pm.expect(groupAcl.relationships).to.include('viewer');",
                  "        pm.expect(groupAcl.relationships).to.include('editor');",
                  "        pm.expect(groupAcl.relationships).to.include('sharer');",
                  "        pm.expect(groupAcl.relationships).to.include('administrator');",
                  "    });",
                  "    ",
                  "    // ACL MODIFICATION TESTS (optional - only run if scenario1Message exists)",
                  "    const scenario1Message = pm.environment.get('nmdMessage_scenario1');",
                  "    const scenario2Message = pm.environment.get('nmdMessage_scenario2');",
                  "    ",
                  "    if (scenario1Message && scenario2Message) {",
                  "        const msg1 = JSON.parse(scenario1Message);",
                  "        const msg2 = JSON.parse(scenario2Message);",
                  "        ",
                  "        // Check if this is an ACL modification test",
                  "        if (msg1.documents && msg1.documents['1'].docProps.name.includes('ACL Modification')) {",
                  "            console.log('');",
                  "            console.log('üî¨ ACL MODIFICATION TEST DETECTED');",
                  "            console.log('   Running enhanced ACL validation...');",
                  "            ",
                  "            const initialAcl = msg1.envProps.acl || [];",
                  "            const modifiedAcl = msg2.envProps.acl || [];",
                  "            const actualAcl = doc.aclPermissions.relationships;",
                  "            ",
                  "            pm.test('ACL Modification: Entry count matches modified sample', function () {",
                  "                pm.expect(actualAcl.length).to.equal(modifiedAcl.length);",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New user DUCOT-user2 present', function () {",
                  "                const user2 = actualAcl.find(e => e.subjectId === 'DUCOT-user2');",
                  "                pm.expect(user2).to.not.be.undefined;",
                  "                pm.expect(user2.subjectType).to.eql('user');",
                  "                pm.expect(user2.relationships).to.include('viewer');",
                  "                pm.expect(user2.relationships).to.include('editor');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New group UG-NEWGROUP present', function () {",
                  "                const newGroup = actualAcl.find(e => e.subjectId === 'UG-NEWGROUP');",
                  "                pm.expect(newGroup).to.not.be.undefined;",
                  "                pm.expect(newGroup.subjectType).to.eql('group');",
                  "                pm.expect(newGroup.relationships).to.include('viewer');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: Cabinet NG-8RZI6EOH removed', function () {",
                  "                const cabinet = actualAcl.find(e => e.subjectId === 'NG-8RZI6EOH');",
                  "                pm.expect(cabinet).to.be.undefined;",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: DUCOT-pbs.nonadmin permissions modified (VE only)', function () {",
                  "                const user = actualAcl.find(e => e.subjectId === 'DUCOT-pbs.nonadmin');",
                  "                pm.expect(user).to.not.be.undefined;",
                  "                pm.expect(user.relationships).to.include('viewer');",
                  "                pm.expect(user.relationships).to.include('editor');",
                  "                pm.expect(user.relationships).to.not.include('sharer');",
                  "                pm.expect(user.relationships).to.not.include('administrator');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: UG-LGSFSO0I unchanged (VESD)', function () {",
                  "                const group = actualAcl.find(e => e.subjectId === 'UG-LGSFSO0I');",
                  "                pm.expect(group).to.not.be.undefined;",
                  "                pm.expect(group.relationships).to.include('viewer');",
                  "                pm.expect(group.relationships).to.include('editor');",
                  "                pm.expect(group.relationships).to.include('sharer');",
                  "                pm.expect(group.relationships).to.include('administrator');",
                  "            });",
                  "            ",
                  "            console.log('   ‚úÖ ACL modification validation complete');",
                  "        }",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ ACL Validation:');",
                  "    console.log(`   Object Type: ${doc.aclPermissions.objectType}`);",
                  "    console.log(`   Object ID: ${doc.aclPermissions.objectId}`);",
                  "    console.log(`   Total ACL Entries: ${doc.aclPermissions.relationships.length}`);",
                  "    doc.aclPermissions.relationships.forEach((entry, idx) => {",
                  "        console.log(`   Entry ${idx + 1}:`);",
                  "        console.log(`      Subject: ${entry.subjectId} (${entry.subjectType})`);",
                  "        console.log(`      Relationships: ${entry.relationships.join(', ')}`);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the ACL was correctly transformed from NMD format (VESD) to SpiceDB relations (viewer, editor, sharer, administrator)."
          },
          "response": []
        },
        {
          "name": "Validate ModNums",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Modification Numbers');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ModNums', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.docModNum).to.not.be.null;",
                  "    pm.expect(doc.nameModNum).to.not.be.null;",
                  "    pm.expect(doc.contentModNum).to.not.be.null;",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "pm.test('ModNums are valid ISO 8601 timestamps', function () {",
                  "    var isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;",
                  "    pm.expect(doc.docModNum).to.match(isoRegex);",
                  "    pm.expect(doc.nameModNum).to.match(isoRegex);",
                  "    pm.expect(doc.contentModNum).to.match(isoRegex);",
                  "});",
                  "",
                  "pm.test('Document has modified timestamp', function () {",
                  "    pm.expect(doc.modified).to.have.property('timestamp');",
                  "    pm.expect(doc.modified.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "pm.test('Document has created timestamp', function () {",
                  "    pm.expect(doc.created).to.have.property('timestamp');",
                  "    pm.expect(doc.created.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ ModNum Validation:');",
                  "console.log(`   DocModNum: ${doc.docModNum} (ISO 8601 format)`);",
                  "console.log(`   NameModNum: ${doc.nameModNum}`);",
                  "console.log(`   ContentModNum: ${doc.contentModNum}`);",
                  "console.log(`   Created: ${doc.created.timestamp}`);",
                  "console.log(`   Modified: ${doc.modified.timestamp}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that modification numbers (ModNums) were correctly set and incremented between scenarios."
          },
          "response": []
        },
        {
          "name": "Validation Summary",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üìä FINAL VALIDATION SUMMARY');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var doc = pm.response.json();",
                  "",
                  "console.log('');",
                  "console.log('üéâ ALL VALIDATIONS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã Complete Document State:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   Official Version: ${doc.officialVersion}`);",
                  "console.log(`   Next Version: ${doc.nextVersion}`);",
                  "console.log(`   Versions Count: ${doc.versions ? doc.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${doc.acl ? doc.acl.length : 0}`);",
                  "console.log(`   DocModNum: ${doc.docModNum}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);",
                  "console.log('');",
                  "console.log('‚úÖ Scenario 1 (CREATE): Verified');",
                  "console.log('‚úÖ Scenario 2 (UPDATE): Verified');",
                  "console.log('‚úÖ Data Integrity: Confirmed');",
                  "console.log('');",
                  "console.log('='.repeat(50));",
                  "console.log('‚úÖ POC VALIDATION SUCCESSFUL!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Final validation that prints a comprehensive summary of the document state after both scenarios."
          },
          "response": []
        }
      ]
    },
    {
      "name": "08 - Test Scenario: WOPI Test File",
      "item": [
        {
          "name": "Step 1: Load WOPI Test File Sample",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load WOPI Test File sample",
                  "const sample = pm.environment.get('sample_wopi_test');",
                  "",
                  "if (sample) {",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate dynamic document ID",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ TEST SCENARIO: WOPI TEST FILE');",
                  "    console.log(\"=\".repeat(60));",
                  "    console.log('   WOPI test file for Office 365 - 12% of production');",
                  "    console.log('   ‚òÅÔ∏è Note: Used for Office 365 integration testing');",
                  "    console.log(`   Document ID: ${newDocId}`);",
                  "    console.log(\"=\".repeat(60));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded\", function () {",
                  "    pm.expect(pm.environment.get(\"nmdMessage\")).to.not.be.empty;",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Extract Content Metadata from NMD",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Extract content-related metadata from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('sample_wopi_test'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const version = doc.versions['1'];",
                  "",
                  "// Extract filename and extension",
                  "const docName = doc.docProps.name;",
                  "const extension = version.verProps.exten;",
                  "const filename = `${docName}.${extension}`;",
                  "",
                  "// Extract user ID and timestamp",
                  "const userId = nmdMessage.envProps.authorguid;",
                  "const createdTimestamp = new Date(parseInt(version.verProps.created.match(/\\d+/)[0])).toISOString();",
                  "",
                  "// Save to environment",
                  "pm.environment.set('contentFilename', filename);",
                  "pm.environment.set('contentExtension', extension);",
                  "pm.environment.set('userId', userId);",
                  "",
                  "console.log('');",
                  "console.log('üìÑ CONTENT METADATA EXTRACTION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üî§ Extension: ${extension}`);",
                  "console.log(`üë§ User ID: ${userId}`);",
                  "console.log(`‚è∞ Created: ${createdTimestamp}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// This is just a setup request, no actual HTTP call needed",
                  "pm.test('Content metadata extracted', function () {",
                  "    const filename = pm.environment.get('contentFilename');",
                  "    const extension = pm.environment.get('contentExtension');",
                  "    const userId = pm.environment.get('userId');",
                  "    ",
                  "    pm.expect(filename).to.not.be.empty;",
                  "    pm.expect(extension).to.not.be.empty;",
                  "    pm.expect(userId).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Content metadata ready for snapshot creation');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Extracts content metadata from NMD message (filename, extension, userId) needed for snapshot creation.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Create Snapshot & Get Presigned URL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('üì∏ CREATING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üåê Requesting presigned URL from Content API...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot created successfully', function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                  "});",
                  "",
                  "const response = pm.response.json();",
                  "",
                  "pm.test('Response contains presigned URL', function () {",
                  "    pm.expect(response.presignedUrl).to.be.a('string');",
                  "    pm.expect(response.presignedUrl).to.include('s3');",
                  "});",
                  "",
                  "// Note: entityId is null initially, gets generated after content upload",
                  "pm.test('Response has entityId field', function () {",
                  "    pm.expect(response).to.have.property('entityId');",
                  "});",
                  "",
                  "// Save presigned URL and object key for later verification",
                  "pm.environment.set('presignedUrl', response.presignedUrl);",
                  "pm.environment.set('snapshotObjectKey', response.objectKey);",
                  "",
                  "console.log('‚úÖ Snapshot created:');",
                  "console.log(`   üì¶ Object Key: ${response.objectKey}`);",
                  "console.log(`   üîó Presigned URL: ${response.presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"contentType\": \"text/plain\",\n  \"filename\": \"{{contentFilename}}\",\n  \"extension\": \"{{contentExtension}}\",\n  \"createdByUserId\": \"{{userId}}\",\n  \"createdTimestamp\": \"{{$isoTimestamp}}\",\n  \"location\": \"poc-test\",\n  \"source\": \"doc-ndserver-sync-wrk-poc\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Creates a snapshot entity in the Content API and retrieves a presigned S3 URL for uploading the document content.\n\nThis corresponds to Phase 1.3 in the integration test."
          },
          "response": []
        },
        {
          "name": "Upload Content to S3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const presignedUrl = pm.environment.get('presignedUrl');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('‚òÅÔ∏è  UPLOADING TO S3');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù File: ${filename}`);",
                  "console.log(`üîó URL: ${presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Content uploaded to S3 successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "console.log('‚úÖ Content uploaded successfully to S3');",
                  "console.log('   üì¶ Document now has both metadata AND content');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/octet-stream"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "This is test content for POC document {{documentId}}.\nCreated at: {{$isoTimestamp}}\nFilename: {{contentFilename}}\n\nThis content was uploaded as part of the doc-ndserver-sync-wrk POC test to verify the complete document lifecycle including content upload to S3."
            },
            "url": {
              "raw": "{{presignedUrl}}",
              "host": [
                "{{presignedUrl}}"
              ]
            },
            "description": "Uploads the document content to S3 using the presigned URL obtained from the Content API.\n\nThis corresponds to Phase 1.4 in the integration test."
          },
          "response": []
        },
        {
          "name": "Verify Snapshot Exists",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const snapshotId = pm.environment.get('snapshotId');",
                  "",
                  "console.log('');",
                  "console.log('üîç VERIFYING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìã Snapshot ID: ${snapshotId}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot retrieved successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "const snapshotResponse = pm.response.json();",
                  "const snapshots = snapshotResponse.results || snapshotResponse;",
                  "const objectKey = pm.environment.get('snapshotObjectKey');",
                  "const expectedExtension = pm.environment.get('contentExtension');",
                  "",
                  "pm.test('Snapshot list contains snapshots', function () {",
                  "    pm.expect(snapshots).to.be.an('array');",
                  "    pm.expect(snapshots.length).to.be.at.least(1);",
                  "});",
                  "",
                  "// Find snapshot by objectKey since entityId is generated after upload",
                  "const createdSnapshot = snapshots.find(s => s.objectKey === objectKey);",
                  "",
                  "pm.test('Created snapshot found in list', function () {",
                  "    pm.expect(createdSnapshot).to.not.be.undefined;",
                  "});",
                  "",
                  "pm.test('Snapshot has correct extension', function () {",
                  "    pm.expect(createdSnapshot.extension).to.equal(expectedExtension);",
                  "});",
                  "",
                  "pm.test('Snapshot has content uploaded', function () {",
                  "    pm.expect(createdSnapshot.length).to.be.above(0);",
                  "});",
                  "",
                  "console.log('‚úÖ Snapshot verified:');",
                  "console.log(`   üìã Entity ID: ${createdSnapshot.entityId}`);",
                  "console.log(`   üî§ Extension: ${createdSnapshot.extension}`);",
                  "console.log(`   üì¶ Size: ${createdSnapshot.length} bytes`);",
                  "console.log(`   ‚úîÔ∏è  Content upload complete!`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Verifies that the snapshot was successfully created and contains the uploaded content."
          },
          "response": []
        },
        {
          "name": "S1 - Step 1: Check Document Existence (Expect 404)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "pm.environment.set('nmdMessage', pm.environment.get('nmdMessage_scenario1'));",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 1: NEW DOCUMENT CREATION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 404 (document doesn't exist)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(404);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'true');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document not found (404)');",
                  "console.log('   Ready to CREATE new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Checks if the document already exists in the metadata API.\n\nExpected for POC: 404 Not Found (new document)"
          },
          "response": []
        },
        {
          "name": "S1 - Step 2: Configure Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Build documentRoot from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "",
                  "// Format: [\"NG-CABID/documents\"]",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "",
                  "console.log(`üìÅ Configuring content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 204 (content root set)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root configured for new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            },
            "description": "Updates the content service metadata to set the document root location.\n\nThis configures where content files are stored in S3."
          },
          "response": []
        },
        {
          "name": "S1 - Step 3: Build CREATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === MINIMAL TRANSFORMATION FOR POC ===",
                  "// This is a simplified version for new document creation only",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "// Helper: Convert NetDocuments date format",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "// Helper: Build ACL",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = {",
                  "        'V': 'viewer',",
                  "        'E': 'editor',",
                  "        'S': 'sharer',",
                  "        'D': 'administrator',",
                  "        'Z': 'default'",
                  "    };",
                  "    ",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        ",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        ",
                  "        return {",
                  "            SubjectType: subjectType,",
                  "            SubjectId: entry.guid,",
                  "            Relations: relations",
                  "        };",
                  "    });",
                  "}",
                  "",
                  "// Helper: Build versions list",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    ",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        ",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: {",
                  "                UserId: props.creatorguid,",
                  "                Timestamp: convertDate(props.created)",
                  "            },",
                  "            Modified: {",
                  "                UserId: props.modifiedByGuid || props.creatorguid,",
                  "                Timestamp: convertDate(props.modified || props.created)",
                  "            },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    ",
                  "    return versionsList;",
                  "}",
                  "",
                  "// Build minimal patch request for NEW document",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: docProps.name,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum),",
                  "    NameModNum: parseInt(docProps.nameModNum),",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: {",
                  "        UserId: envProps.authorguid,",
                  "        Timestamp: convertDate(envProps.created)",
                  "    },",
                  "    Modified: {",
                  "        UserId: envProps['modified by guid'],",
                  "        Timestamp: convertDate(envProps.modified)",
                  "    },",
                  "    CheckedOut: {",
                  "        UserId: null,",
                  "        Timestamp: null,",
                  "        Comment: null,",
                  "        CollaborationEdit: null,",
                  "        CollaborationEditType: null",
                  "    },",
                  "    Locked: {",
                  "        UserId: null,",
                  "        Comment: null,",
                  "        Timestamp: null",
                  "    },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "",
                  "console.log('‚úÖ CREATE patch request built');",
                  "console.log(`   Document: ${patchRequest.Name}`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to CREATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Builds the patch request by transforming the NMD message.\n\nThis is a dummy request that only runs the pre-request script to build the patchRequest variable.\n\nFor POC: Simplified transformation for new document creation only."
          },
          "response": []
        },
        {
          "name": "S1 - Step 4: CREATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üöÄ CREATING new document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Document created successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "",
                  "// Store created document for Scenario 2",
                  "pm.environment.set('scenario1_created_document', JSON.stringify(response));",
                  "pm.environment.set('scenario1_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 1 COMPLETE: Document CREATED');",
                  "console.log('üìä Created Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Cabinet ID: ${response.cabinetId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${response.acl ? response.acl.length : 0}`);",
                  "console.log('');",
                  "console.log('‚û°Ô∏è  Document ready for Scenario 2 (UPDATE)');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Creates/updates the document in the metadata API.\n\nFor POC: Creates a new document with metadata, versions, and ACLs.\n\nThis is the main synchronization call."
          },
          "response": []
        },
        {
          "name": "S2 - Step 1: Check Document Existence (Expect 200)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 2: DOCUMENT UPDATE');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists (should be 200)...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 200 (document exists)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var extendedDoc = pm.response.json();",
                  "pm.environment.set('existingDocument', JSON.stringify(extendedDoc));",
                  "pm.environment.set('scenario2_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'false');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document found (200 OK)');",
                  "console.log(`   Document State: ${extendedDoc.state}`);",
                  "console.log(`   Current Versions: ${extendedDoc.versions ? extendedDoc.versions.length : 0}`);",
                  "console.log('   Ready to UPDATE existing document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 2: Update Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "console.log(`üìÅ Updating content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 204 (content root updated)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario2_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root updated');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 3: Build UPDATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === BUILD PATCH REQUEST FOR UPDATING DOCUMENT ===",
                  "// This simulates a change: update document name with timestamp",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = { 'V': 'viewer', 'E': 'editor', 'S': 'sharer', 'D': 'administrator', 'Z': 'default' };",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        return { SubjectType: subjectType, SubjectId: entry.guid, Relations: relations };",
                  "    });",
                  "}",
                  "",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: { UserId: props.creatorguid, Timestamp: convertDate(props.created) },",
                  "            Modified: { UserId: props.modifiedByGuid || props.creatorguid, Timestamp: convertDate(props.modified || props.created) },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    return versionsList;",
                  "}",
                  "",
                  "// SIMULATE A CHANGE: Update document name",
                  "const updatedName = docProps.name + ' [UPDATED]';",
                  "const now = new Date().toISOString();",
                  "",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: updatedName,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum) + 1,",
                  "    NameModNum: parseInt(docProps.nameModNum) + 1,",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: { UserId: envProps.authorguid, Timestamp: convertDate(envProps.created) },",
                  "    Modified: { UserId: envProps['modified by guid'], Timestamp: now },",
                  "    CheckedOut: { UserId: null, Timestamp: null, Comment: null, CollaborationEdit: null, CollaborationEditType: null },",
                  "    Locked: { UserId: null, Comment: null, Timestamp: null },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "console.log('‚úÖ UPDATE patch request built');",
                  "console.log(`   CHANGE: Name updated to: ${updatedName}`);",
                  "console.log(`   CHANGE: Modified timestamp: ${now}`);",
                  "console.log(`   CHANGE: DocModNum incremented`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to UPDATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 4: UPDATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üîÑ UPDATING existing document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Document updated successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "pm.environment.set('scenario2_updated_document', JSON.stringify(response));",
                  "pm.environment.set('scenario2_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 2 COMPLETE: Document UPDATED');",
                  "console.log('üìä Updated Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log('');",
                  "console.log('üéâ BOTH SCENARIOS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã SUMMARY:');",
                  "console.log(`   Scenario 1 - Step 1: ${pm.environment.get('scenario1_step1_status')} (Expected: 404)`);",
                  "console.log(`   Scenario 1 - Step 4: ${pm.environment.get('scenario1_step4_status')} (Expected: 200 - CREATE)`);",
                  "console.log(`   Scenario 2 - Step 1: ${pm.environment.get('scenario2_step1_status')} (Expected: 200 - EXISTS)`);",
                  "console.log(`   Scenario 2 - Step 4: ${pm.environment.get('scenario2_step4_status')} (Expected: 200 - UPDATE)`);",
                  "console.log('');",
                  "console.log('‚úÖ POC validated BOTH workflows successfully!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Validate Document Metadata",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Document Metadata');",
                  "console.log('='.repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get('documentId')}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document exists (200 OK)', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "var expectedDocId = pm.environment.get('documentId');",
                  "",
                  "pm.test('Document ID matches', function () {",
                  "    pm.expect(doc.documentId).to.eql(expectedDocId);",
                  "});",
                  "",
                  "pm.test('Document state is ACTIVE', function () {",
                  "    pm.expect(doc.state).to.eql('ACTIVE');",
                  "});",
                  "",
                  "pm.test('Cabinet ID is set', function () {",
                  "    pm.expect(doc.cabinetId).to.not.be.empty;",
                  "    pm.expect(doc.cabinetId).to.eql('NG-8RZI6EOH');",
                  "});",
                  "",
                  "pm.test('Document name was updated in Scenario 2', function () {",
                  "    pm.expect(doc.name).to.include('[UPDATED]');",
                  "});",
                  "",
                  "pm.test('EnvUrl is set', function () {",
                  "    pm.expect(doc.envUrl).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ Document Metadata Validation:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document created in Scenario 1 and updated in Scenario 2 exists with correct metadata."
          },
          "response": []
        },
        {
          "name": "Validate Versions",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Version Information');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has versions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.versions).to.be.an('array');",
                  "    pm.expect(doc.versions.length).to.be.at.least(1);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.versions && doc.versions.length > 0) {",
                  "    var version1 = doc.versions[0];",
                  "    ",
                  "    pm.test('Version 1 exists', function () {",
                  "        pm.expect(version1.versionId).to.eql(1);",
                  "    });",
                  "    ",
                  "    pm.test('Version has extension', function () {",
                  "        pm.expect(version1.extension).to.eql('txt');",
                  "    });",
                  "    ",
                  "    pm.test('Version has label', function () {",
                  "        pm.expect(version1.label).to.eql('1.0');",
                  "    });",
                  "    ",
                  "    pm.test('Version state is ACTIVE', function () {",
                  "        pm.expect(version1.state).to.eql('ACTIVE');",
                  "    });",
                  "    ",
                  "    pm.test('Version has created timestamp', function () {",
                  "        pm.expect(version1.created).to.have.property('timestamp');",
                  "        pm.expect(version1.created.timestamp).to.not.be.empty;",
                  "    });",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ Version Validation:');",
                  "    console.log(`   Version ID: ${version1.versionId}`);",
                  "    console.log(`   Label: ${version1.label}`);",
                  "    console.log(`   Extension: ${version1.extension}`);",
                  "    console.log(`   Size: ${version1.size} bytes`);",
                  "    console.log(`   State: ${version1.state}`);",
                  "    console.log(`   Created: ${version1.created.timestamp}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document has the correct version information from the NMD message."
          },
          "response": []
        },
        {
          "name": "Validate ACL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying ACL Configuration');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ACL permissions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.aclPermissions).to.be.an('object');",
                  "    pm.expect(doc.aclPermissions.relationships).to.be.an('array');",
                  "    pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.aclPermissions && doc.aclPermissions.relationships) {",
                  "    pm.test('ACL has expected entries', function () {",
                  "        pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "    });",
                  "    ",
                  "    var groupAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'UG-LGSFSO0I');",
                  "    var userAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'DUCOT-pbs.nonadmin');",
                  "    ",
                  "    pm.test('Group ACL entry exists', function () {",
                  "        pm.expect(groupAcl).to.not.be.undefined;",
                  "        pm.expect(groupAcl.subjectType).to.eql('group');",
                  "    });",
                  "    ",
                  "    pm.test('User ACL entry exists', function () {",
                  "        pm.expect(userAcl).to.not.be.undefined;",
                  "        pm.expect(userAcl.subjectType).to.eql('user');",
                  "    });",
                  "    ",
                  "    pm.test('ACL has correct relationships (VESD)', function () {",
                  "        pm.expect(groupAcl.relationships).to.include('viewer');",
                  "        pm.expect(groupAcl.relationships).to.include('editor');",
                  "        pm.expect(groupAcl.relationships).to.include('sharer');",
                  "        pm.expect(groupAcl.relationships).to.include('administrator');",
                  "    });",
                  "    ",
                  "    // ACL MODIFICATION TESTS (optional - only run if scenario1Message exists)",
                  "    const scenario1Message = pm.environment.get('nmdMessage_scenario1');",
                  "    const scenario2Message = pm.environment.get('nmdMessage_scenario2');",
                  "    ",
                  "    if (scenario1Message && scenario2Message) {",
                  "        const msg1 = JSON.parse(scenario1Message);",
                  "        const msg2 = JSON.parse(scenario2Message);",
                  "        ",
                  "        // Check if this is an ACL modification test",
                  "        if (msg1.documents && msg1.documents['1'].docProps.name.includes('ACL Modification')) {",
                  "            console.log('');",
                  "            console.log('üî¨ ACL MODIFICATION TEST DETECTED');",
                  "            console.log('   Running enhanced ACL validation...');",
                  "            ",
                  "            const initialAcl = msg1.envProps.acl || [];",
                  "            const modifiedAcl = msg2.envProps.acl || [];",
                  "            const actualAcl = doc.aclPermissions.relationships;",
                  "            ",
                  "            pm.test('ACL Modification: Entry count matches modified sample', function () {",
                  "                pm.expect(actualAcl.length).to.equal(modifiedAcl.length);",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New user DUCOT-user2 present', function () {",
                  "                const user2 = actualAcl.find(e => e.subjectId === 'DUCOT-user2');",
                  "                pm.expect(user2).to.not.be.undefined;",
                  "                pm.expect(user2.subjectType).to.eql('user');",
                  "                pm.expect(user2.relationships).to.include('viewer');",
                  "                pm.expect(user2.relationships).to.include('editor');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New group UG-NEWGROUP present', function () {",
                  "                const newGroup = actualAcl.find(e => e.subjectId === 'UG-NEWGROUP');",
                  "                pm.expect(newGroup).to.not.be.undefined;",
                  "                pm.expect(newGroup.subjectType).to.eql('group');",
                  "                pm.expect(newGroup.relationships).to.include('viewer');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: Cabinet NG-8RZI6EOH removed', function () {",
                  "                const cabinet = actualAcl.find(e => e.subjectId === 'NG-8RZI6EOH');",
                  "                pm.expect(cabinet).to.be.undefined;",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: DUCOT-pbs.nonadmin permissions modified (VE only)', function () {",
                  "                const user = actualAcl.find(e => e.subjectId === 'DUCOT-pbs.nonadmin');",
                  "                pm.expect(user).to.not.be.undefined;",
                  "                pm.expect(user.relationships).to.include('viewer');",
                  "                pm.expect(user.relationships).to.include('editor');",
                  "                pm.expect(user.relationships).to.not.include('sharer');",
                  "                pm.expect(user.relationships).to.not.include('administrator');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: UG-LGSFSO0I unchanged (VESD)', function () {",
                  "                const group = actualAcl.find(e => e.subjectId === 'UG-LGSFSO0I');",
                  "                pm.expect(group).to.not.be.undefined;",
                  "                pm.expect(group.relationships).to.include('viewer');",
                  "                pm.expect(group.relationships).to.include('editor');",
                  "                pm.expect(group.relationships).to.include('sharer');",
                  "                pm.expect(group.relationships).to.include('administrator');",
                  "            });",
                  "            ",
                  "            console.log('   ‚úÖ ACL modification validation complete');",
                  "        }",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ ACL Validation:');",
                  "    console.log(`   Object Type: ${doc.aclPermissions.objectType}`);",
                  "    console.log(`   Object ID: ${doc.aclPermissions.objectId}`);",
                  "    console.log(`   Total ACL Entries: ${doc.aclPermissions.relationships.length}`);",
                  "    doc.aclPermissions.relationships.forEach((entry, idx) => {",
                  "        console.log(`   Entry ${idx + 1}:`);",
                  "        console.log(`      Subject: ${entry.subjectId} (${entry.subjectType})`);",
                  "        console.log(`      Relationships: ${entry.relationships.join(', ')}`);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the ACL was correctly transformed from NMD format (VESD) to SpiceDB relations (viewer, editor, sharer, administrator)."
          },
          "response": []
        },
        {
          "name": "Validate ModNums",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Modification Numbers');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ModNums', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.docModNum).to.not.be.null;",
                  "    pm.expect(doc.nameModNum).to.not.be.null;",
                  "    pm.expect(doc.contentModNum).to.not.be.null;",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "pm.test('ModNums are valid ISO 8601 timestamps', function () {",
                  "    var isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;",
                  "    pm.expect(doc.docModNum).to.match(isoRegex);",
                  "    pm.expect(doc.nameModNum).to.match(isoRegex);",
                  "    pm.expect(doc.contentModNum).to.match(isoRegex);",
                  "});",
                  "",
                  "pm.test('Document has modified timestamp', function () {",
                  "    pm.expect(doc.modified).to.have.property('timestamp');",
                  "    pm.expect(doc.modified.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "pm.test('Document has created timestamp', function () {",
                  "    pm.expect(doc.created).to.have.property('timestamp');",
                  "    pm.expect(doc.created.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ ModNum Validation:');",
                  "console.log(`   DocModNum: ${doc.docModNum} (ISO 8601 format)`);",
                  "console.log(`   NameModNum: ${doc.nameModNum}`);",
                  "console.log(`   ContentModNum: ${doc.contentModNum}`);",
                  "console.log(`   Created: ${doc.created.timestamp}`);",
                  "console.log(`   Modified: ${doc.modified.timestamp}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that modification numbers (ModNums) were correctly set and incremented between scenarios."
          },
          "response": []
        },
        {
          "name": "Validation Summary",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üìä FINAL VALIDATION SUMMARY');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var doc = pm.response.json();",
                  "",
                  "console.log('');",
                  "console.log('üéâ ALL VALIDATIONS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã Complete Document State:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   Official Version: ${doc.officialVersion}`);",
                  "console.log(`   Next Version: ${doc.nextVersion}`);",
                  "console.log(`   Versions Count: ${doc.versions ? doc.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${doc.acl ? doc.acl.length : 0}`);",
                  "console.log(`   DocModNum: ${doc.docModNum}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);",
                  "console.log('');",
                  "console.log('‚úÖ Scenario 1 (CREATE): Verified');",
                  "console.log('‚úÖ Scenario 2 (UPDATE): Verified');",
                  "console.log('‚úÖ Data Integrity: Confirmed');",
                  "console.log('');",
                  "console.log('='.repeat(50));",
                  "console.log('‚úÖ POC VALIDATION SUCCESSFUL!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Final validation that prints a comprehensive summary of the document state after both scenarios."
          },
          "response": []
        }
      ]
    },
    {
      "name": "09 - Test Scenario: Email Document",
      "item": [
        {
          "name": "Step 1: Load Email Message Sample",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load Email Message sample",
                  "const sample = pm.environment.get('sample_email');",
                  "",
                  "if (sample) {",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate dynamic document ID",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ TEST SCENARIO: EMAIL MESSAGE');",
                  "    console.log(\"=\".repeat(60));",
                  "    console.log('   Email message (.eml) - 3% of production');",
                  "    console.log('   üìß Note: Includes emailProps metadata');",
                  "    console.log(`   Document ID: ${newDocId}`);",
                  "    console.log(\"=\".repeat(60));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded\", function () {",
                  "    pm.expect(pm.environment.get(\"nmdMessage\")).to.not.be.empty;",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Extract Content Metadata from NMD",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Extract content-related metadata from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('sample_email'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const version = doc.versions['1'];",
                  "",
                  "// Extract filename and extension",
                  "const docName = doc.docProps.name;",
                  "const extension = version.verProps.exten;",
                  "const filename = `${docName}.${extension}`;",
                  "",
                  "// Extract user ID and timestamp",
                  "const userId = nmdMessage.envProps.authorguid;",
                  "const createdTimestamp = new Date(parseInt(version.verProps.created.match(/\\d+/)[0])).toISOString();",
                  "",
                  "// Save to environment",
                  "pm.environment.set('contentFilename', filename);",
                  "pm.environment.set('contentExtension', extension);",
                  "pm.environment.set('userId', userId);",
                  "",
                  "console.log('');",
                  "console.log('üìÑ CONTENT METADATA EXTRACTION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üî§ Extension: ${extension}`);",
                  "console.log(`üë§ User ID: ${userId}`);",
                  "console.log(`‚è∞ Created: ${createdTimestamp}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// This is just a setup request, no actual HTTP call needed",
                  "pm.test('Content metadata extracted', function () {",
                  "    const filename = pm.environment.get('contentFilename');",
                  "    const extension = pm.environment.get('contentExtension');",
                  "    const userId = pm.environment.get('userId');",
                  "    ",
                  "    pm.expect(filename).to.not.be.empty;",
                  "    pm.expect(extension).to.not.be.empty;",
                  "    pm.expect(userId).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Content metadata ready for snapshot creation');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Extracts content metadata from NMD message (filename, extension, userId) needed for snapshot creation.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Create Snapshot & Get Presigned URL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('üì∏ CREATING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üåê Requesting presigned URL from Content API...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot created successfully', function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                  "});",
                  "",
                  "const response = pm.response.json();",
                  "",
                  "pm.test('Response contains presigned URL', function () {",
                  "    pm.expect(response.presignedUrl).to.be.a('string');",
                  "    pm.expect(response.presignedUrl).to.include('s3');",
                  "});",
                  "",
                  "// Note: entityId is null initially, gets generated after content upload",
                  "pm.test('Response has entityId field', function () {",
                  "    pm.expect(response).to.have.property('entityId');",
                  "});",
                  "",
                  "// Save presigned URL and object key for later verification",
                  "pm.environment.set('presignedUrl', response.presignedUrl);",
                  "pm.environment.set('snapshotObjectKey', response.objectKey);",
                  "",
                  "console.log('‚úÖ Snapshot created:');",
                  "console.log(`   üì¶ Object Key: ${response.objectKey}`);",
                  "console.log(`   üîó Presigned URL: ${response.presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"contentType\": \"text/plain\",\n  \"filename\": \"{{contentFilename}}\",\n  \"extension\": \"{{contentExtension}}\",\n  \"createdByUserId\": \"{{userId}}\",\n  \"createdTimestamp\": \"{{$isoTimestamp}}\",\n  \"location\": \"poc-test\",\n  \"source\": \"doc-ndserver-sync-wrk-poc\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Creates a snapshot entity in the Content API and retrieves a presigned S3 URL for uploading the document content.\n\nThis corresponds to Phase 1.3 in the integration test."
          },
          "response": []
        },
        {
          "name": "Upload Content to S3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const presignedUrl = pm.environment.get('presignedUrl');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('‚òÅÔ∏è  UPLOADING TO S3');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù File: ${filename}`);",
                  "console.log(`üîó URL: ${presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Content uploaded to S3 successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "console.log('‚úÖ Content uploaded successfully to S3');",
                  "console.log('   üì¶ Document now has both metadata AND content');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/octet-stream"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "This is test content for POC document {{documentId}}.\nCreated at: {{$isoTimestamp}}\nFilename: {{contentFilename}}\n\nThis content was uploaded as part of the doc-ndserver-sync-wrk POC test to verify the complete document lifecycle including content upload to S3."
            },
            "url": {
              "raw": "{{presignedUrl}}",
              "host": [
                "{{presignedUrl}}"
              ]
            },
            "description": "Uploads the document content to S3 using the presigned URL obtained from the Content API.\n\nThis corresponds to Phase 1.4 in the integration test."
          },
          "response": []
        },
        {
          "name": "Verify Snapshot Exists",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const snapshotId = pm.environment.get('snapshotId');",
                  "",
                  "console.log('');",
                  "console.log('üîç VERIFYING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìã Snapshot ID: ${snapshotId}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot retrieved successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "const snapshotResponse = pm.response.json();",
                  "const snapshots = snapshotResponse.results || snapshotResponse;",
                  "const objectKey = pm.environment.get('snapshotObjectKey');",
                  "const expectedExtension = pm.environment.get('contentExtension');",
                  "",
                  "pm.test('Snapshot list contains snapshots', function () {",
                  "    pm.expect(snapshots).to.be.an('array');",
                  "    pm.expect(snapshots.length).to.be.at.least(1);",
                  "});",
                  "",
                  "// Find snapshot by objectKey since entityId is generated after upload",
                  "const createdSnapshot = snapshots.find(s => s.objectKey === objectKey);",
                  "",
                  "pm.test('Created snapshot found in list', function () {",
                  "    pm.expect(createdSnapshot).to.not.be.undefined;",
                  "});",
                  "",
                  "pm.test('Snapshot has correct extension', function () {",
                  "    pm.expect(createdSnapshot.extension).to.equal(expectedExtension);",
                  "});",
                  "",
                  "pm.test('Snapshot has content uploaded', function () {",
                  "    pm.expect(createdSnapshot.length).to.be.above(0);",
                  "});",
                  "",
                  "console.log('‚úÖ Snapshot verified:');",
                  "console.log(`   üìã Entity ID: ${createdSnapshot.entityId}`);",
                  "console.log(`   üî§ Extension: ${createdSnapshot.extension}`);",
                  "console.log(`   üì¶ Size: ${createdSnapshot.length} bytes`);",
                  "console.log(`   ‚úîÔ∏è  Content upload complete!`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Verifies that the snapshot was successfully created and contains the uploaded content."
          },
          "response": []
        },
        {
          "name": "S1 - Step 1: Check Document Existence (Expect 404)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "pm.environment.set('nmdMessage', pm.environment.get('nmdMessage_scenario1'));",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 1: NEW DOCUMENT CREATION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 404 (document doesn't exist)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(404);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'true');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document not found (404)');",
                  "console.log('   Ready to CREATE new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Checks if the document already exists in the metadata API.\n\nExpected for POC: 404 Not Found (new document)"
          },
          "response": []
        },
        {
          "name": "S1 - Step 2: Configure Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Build documentRoot from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "",
                  "// Format: [\"NG-CABID/documents\"]",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "",
                  "console.log(`üìÅ Configuring content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 204 (content root set)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root configured for new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            },
            "description": "Updates the content service metadata to set the document root location.\n\nThis configures where content files are stored in S3."
          },
          "response": []
        },
        {
          "name": "S1 - Step 3: Build CREATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === MINIMAL TRANSFORMATION FOR POC ===",
                  "// This is a simplified version for new document creation only",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "// Helper: Convert NetDocuments date format",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "// Helper: Build ACL",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = {",
                  "        'V': 'viewer',",
                  "        'E': 'editor',",
                  "        'S': 'sharer',",
                  "        'D': 'administrator',",
                  "        'Z': 'default'",
                  "    };",
                  "    ",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        ",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        ",
                  "        return {",
                  "            SubjectType: subjectType,",
                  "            SubjectId: entry.guid,",
                  "            Relations: relations",
                  "        };",
                  "    });",
                  "}",
                  "",
                  "// Helper: Build versions list",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    ",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        ",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: {",
                  "                UserId: props.creatorguid,",
                  "                Timestamp: convertDate(props.created)",
                  "            },",
                  "            Modified: {",
                  "                UserId: props.modifiedByGuid || props.creatorguid,",
                  "                Timestamp: convertDate(props.modified || props.created)",
                  "            },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    ",
                  "    return versionsList;",
                  "}",
                  "",
                  "// Build minimal patch request for NEW document",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: docProps.name,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum),",
                  "    NameModNum: parseInt(docProps.nameModNum),",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: {",
                  "        UserId: envProps.authorguid,",
                  "        Timestamp: convertDate(envProps.created)",
                  "    },",
                  "    Modified: {",
                  "        UserId: envProps['modified by guid'],",
                  "        Timestamp: convertDate(envProps.modified)",
                  "    },",
                  "    CheckedOut: {",
                  "        UserId: null,",
                  "        Timestamp: null,",
                  "        Comment: null,",
                  "        CollaborationEdit: null,",
                  "        CollaborationEditType: null",
                  "    },",
                  "    Locked: {",
                  "        UserId: null,",
                  "        Comment: null,",
                  "        Timestamp: null",
                  "    },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "",
                  "console.log('‚úÖ CREATE patch request built');",
                  "console.log(`   Document: ${patchRequest.Name}`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to CREATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Builds the patch request by transforming the NMD message.\n\nThis is a dummy request that only runs the pre-request script to build the patchRequest variable.\n\nFor POC: Simplified transformation for new document creation only."
          },
          "response": []
        },
        {
          "name": "S1 - Step 4: CREATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üöÄ CREATING new document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Document created successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "",
                  "// Store created document for Scenario 2",
                  "pm.environment.set('scenario1_created_document', JSON.stringify(response));",
                  "pm.environment.set('scenario1_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 1 COMPLETE: Document CREATED');",
                  "console.log('üìä Created Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Cabinet ID: ${response.cabinetId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${response.acl ? response.acl.length : 0}`);",
                  "console.log('');",
                  "console.log('‚û°Ô∏è  Document ready for Scenario 2 (UPDATE)');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Creates/updates the document in the metadata API.\n\nFor POC: Creates a new document with metadata, versions, and ACLs.\n\nThis is the main synchronization call."
          },
          "response": []
        },
        {
          "name": "S2 - Step 1: Check Document Existence (Expect 200)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 2: DOCUMENT UPDATE');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists (should be 200)...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 200 (document exists)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var extendedDoc = pm.response.json();",
                  "pm.environment.set('existingDocument', JSON.stringify(extendedDoc));",
                  "pm.environment.set('scenario2_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'false');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document found (200 OK)');",
                  "console.log(`   Document State: ${extendedDoc.state}`);",
                  "console.log(`   Current Versions: ${extendedDoc.versions ? extendedDoc.versions.length : 0}`);",
                  "console.log('   Ready to UPDATE existing document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 2: Update Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "console.log(`üìÅ Updating content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 204 (content root updated)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario2_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root updated');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 3: Build UPDATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === BUILD PATCH REQUEST FOR UPDATING DOCUMENT ===",
                  "// This simulates a change: update document name with timestamp",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = { 'V': 'viewer', 'E': 'editor', 'S': 'sharer', 'D': 'administrator', 'Z': 'default' };",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        return { SubjectType: subjectType, SubjectId: entry.guid, Relations: relations };",
                  "    });",
                  "}",
                  "",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: { UserId: props.creatorguid, Timestamp: convertDate(props.created) },",
                  "            Modified: { UserId: props.modifiedByGuid || props.creatorguid, Timestamp: convertDate(props.modified || props.created) },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    return versionsList;",
                  "}",
                  "",
                  "// SIMULATE A CHANGE: Update document name",
                  "const updatedName = docProps.name + ' [UPDATED]';",
                  "const now = new Date().toISOString();",
                  "",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: updatedName,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum) + 1,",
                  "    NameModNum: parseInt(docProps.nameModNum) + 1,",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: { UserId: envProps.authorguid, Timestamp: convertDate(envProps.created) },",
                  "    Modified: { UserId: envProps['modified by guid'], Timestamp: now },",
                  "    CheckedOut: { UserId: null, Timestamp: null, Comment: null, CollaborationEdit: null, CollaborationEditType: null },",
                  "    Locked: { UserId: null, Comment: null, Timestamp: null },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "console.log('‚úÖ UPDATE patch request built');",
                  "console.log(`   CHANGE: Name updated to: ${updatedName}`);",
                  "console.log(`   CHANGE: Modified timestamp: ${now}`);",
                  "console.log(`   CHANGE: DocModNum incremented`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to UPDATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 4: UPDATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üîÑ UPDATING existing document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Document updated successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "pm.environment.set('scenario2_updated_document', JSON.stringify(response));",
                  "pm.environment.set('scenario2_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 2 COMPLETE: Document UPDATED');",
                  "console.log('üìä Updated Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log('');",
                  "console.log('üéâ BOTH SCENARIOS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã SUMMARY:');",
                  "console.log(`   Scenario 1 - Step 1: ${pm.environment.get('scenario1_step1_status')} (Expected: 404)`);",
                  "console.log(`   Scenario 1 - Step 4: ${pm.environment.get('scenario1_step4_status')} (Expected: 200 - CREATE)`);",
                  "console.log(`   Scenario 2 - Step 1: ${pm.environment.get('scenario2_step1_status')} (Expected: 200 - EXISTS)`);",
                  "console.log(`   Scenario 2 - Step 4: ${pm.environment.get('scenario2_step4_status')} (Expected: 200 - UPDATE)`);",
                  "console.log('');",
                  "console.log('‚úÖ POC validated BOTH workflows successfully!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Validate Document Metadata",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Document Metadata');",
                  "console.log('='.repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get('documentId')}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document exists (200 OK)', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "var expectedDocId = pm.environment.get('documentId');",
                  "",
                  "pm.test('Document ID matches', function () {",
                  "    pm.expect(doc.documentId).to.eql(expectedDocId);",
                  "});",
                  "",
                  "pm.test('Document state is ACTIVE', function () {",
                  "    pm.expect(doc.state).to.eql('ACTIVE');",
                  "});",
                  "",
                  "pm.test('Cabinet ID is set', function () {",
                  "    pm.expect(doc.cabinetId).to.not.be.empty;",
                  "    pm.expect(doc.cabinetId).to.eql('NG-8RZI6EOH');",
                  "});",
                  "",
                  "pm.test('Document name was updated in Scenario 2', function () {",
                  "    pm.expect(doc.name).to.include('[UPDATED]');",
                  "});",
                  "",
                  "pm.test('EnvUrl is set', function () {",
                  "    pm.expect(doc.envUrl).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ Document Metadata Validation:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document created in Scenario 1 and updated in Scenario 2 exists with correct metadata."
          },
          "response": []
        },
        {
          "name": "Validate Versions",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Version Information');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has versions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.versions).to.be.an('array');",
                  "    pm.expect(doc.versions.length).to.be.at.least(1);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.versions && doc.versions.length > 0) {",
                  "    var version1 = doc.versions[0];",
                  "    ",
                  "    pm.test('Version 1 exists', function () {",
                  "        pm.expect(version1.versionId).to.eql(1);",
                  "    });",
                  "    ",
                  "    pm.test('Version has extension', function () {",
                  "        pm.expect(version1.extension).to.eql('txt');",
                  "    });",
                  "    ",
                  "    pm.test('Version has label', function () {",
                  "        pm.expect(version1.label).to.eql('1.0');",
                  "    });",
                  "    ",
                  "    pm.test('Version state is ACTIVE', function () {",
                  "        pm.expect(version1.state).to.eql('ACTIVE');",
                  "    });",
                  "    ",
                  "    pm.test('Version has created timestamp', function () {",
                  "        pm.expect(version1.created).to.have.property('timestamp');",
                  "        pm.expect(version1.created.timestamp).to.not.be.empty;",
                  "    });",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ Version Validation:');",
                  "    console.log(`   Version ID: ${version1.versionId}`);",
                  "    console.log(`   Label: ${version1.label}`);",
                  "    console.log(`   Extension: ${version1.extension}`);",
                  "    console.log(`   Size: ${version1.size} bytes`);",
                  "    console.log(`   State: ${version1.state}`);",
                  "    console.log(`   Created: ${version1.created.timestamp}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document has the correct version information from the NMD message."
          },
          "response": []
        },
        {
          "name": "Validate ACL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying ACL Configuration');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ACL permissions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.aclPermissions).to.be.an('object');",
                  "    pm.expect(doc.aclPermissions.relationships).to.be.an('array');",
                  "    pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.aclPermissions && doc.aclPermissions.relationships) {",
                  "    pm.test('ACL has expected entries', function () {",
                  "        pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "    });",
                  "    ",
                  "    var groupAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'UG-LGSFSO0I');",
                  "    var userAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'DUCOT-pbs.nonadmin');",
                  "    ",
                  "    pm.test('Group ACL entry exists', function () {",
                  "        pm.expect(groupAcl).to.not.be.undefined;",
                  "        pm.expect(groupAcl.subjectType).to.eql('group');",
                  "    });",
                  "    ",
                  "    pm.test('User ACL entry exists', function () {",
                  "        pm.expect(userAcl).to.not.be.undefined;",
                  "        pm.expect(userAcl.subjectType).to.eql('user');",
                  "    });",
                  "    ",
                  "    pm.test('ACL has correct relationships (VESD)', function () {",
                  "        pm.expect(groupAcl.relationships).to.include('viewer');",
                  "        pm.expect(groupAcl.relationships).to.include('editor');",
                  "        pm.expect(groupAcl.relationships).to.include('sharer');",
                  "        pm.expect(groupAcl.relationships).to.include('administrator');",
                  "    });",
                  "    ",
                  "    // ACL MODIFICATION TESTS (optional - only run if scenario1Message exists)",
                  "    const scenario1Message = pm.environment.get('nmdMessage_scenario1');",
                  "    const scenario2Message = pm.environment.get('nmdMessage_scenario2');",
                  "    ",
                  "    if (scenario1Message && scenario2Message) {",
                  "        const msg1 = JSON.parse(scenario1Message);",
                  "        const msg2 = JSON.parse(scenario2Message);",
                  "        ",
                  "        // Check if this is an ACL modification test",
                  "        if (msg1.documents && msg1.documents['1'].docProps.name.includes('ACL Modification')) {",
                  "            console.log('');",
                  "            console.log('üî¨ ACL MODIFICATION TEST DETECTED');",
                  "            console.log('   Running enhanced ACL validation...');",
                  "            ",
                  "            const initialAcl = msg1.envProps.acl || [];",
                  "            const modifiedAcl = msg2.envProps.acl || [];",
                  "            const actualAcl = doc.aclPermissions.relationships;",
                  "            ",
                  "            pm.test('ACL Modification: Entry count matches modified sample', function () {",
                  "                pm.expect(actualAcl.length).to.equal(modifiedAcl.length);",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New user DUCOT-user2 present', function () {",
                  "                const user2 = actualAcl.find(e => e.subjectId === 'DUCOT-user2');",
                  "                pm.expect(user2).to.not.be.undefined;",
                  "                pm.expect(user2.subjectType).to.eql('user');",
                  "                pm.expect(user2.relationships).to.include('viewer');",
                  "                pm.expect(user2.relationships).to.include('editor');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New group UG-NEWGROUP present', function () {",
                  "                const newGroup = actualAcl.find(e => e.subjectId === 'UG-NEWGROUP');",
                  "                pm.expect(newGroup).to.not.be.undefined;",
                  "                pm.expect(newGroup.subjectType).to.eql('group');",
                  "                pm.expect(newGroup.relationships).to.include('viewer');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: Cabinet NG-8RZI6EOH removed', function () {",
                  "                const cabinet = actualAcl.find(e => e.subjectId === 'NG-8RZI6EOH');",
                  "                pm.expect(cabinet).to.be.undefined;",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: DUCOT-pbs.nonadmin permissions modified (VE only)', function () {",
                  "                const user = actualAcl.find(e => e.subjectId === 'DUCOT-pbs.nonadmin');",
                  "                pm.expect(user).to.not.be.undefined;",
                  "                pm.expect(user.relationships).to.include('viewer');",
                  "                pm.expect(user.relationships).to.include('editor');",
                  "                pm.expect(user.relationships).to.not.include('sharer');",
                  "                pm.expect(user.relationships).to.not.include('administrator');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: UG-LGSFSO0I unchanged (VESD)', function () {",
                  "                const group = actualAcl.find(e => e.subjectId === 'UG-LGSFSO0I');",
                  "                pm.expect(group).to.not.be.undefined;",
                  "                pm.expect(group.relationships).to.include('viewer');",
                  "                pm.expect(group.relationships).to.include('editor');",
                  "                pm.expect(group.relationships).to.include('sharer');",
                  "                pm.expect(group.relationships).to.include('administrator');",
                  "            });",
                  "            ",
                  "            console.log('   ‚úÖ ACL modification validation complete');",
                  "        }",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ ACL Validation:');",
                  "    console.log(`   Object Type: ${doc.aclPermissions.objectType}`);",
                  "    console.log(`   Object ID: ${doc.aclPermissions.objectId}`);",
                  "    console.log(`   Total ACL Entries: ${doc.aclPermissions.relationships.length}`);",
                  "    doc.aclPermissions.relationships.forEach((entry, idx) => {",
                  "        console.log(`   Entry ${idx + 1}:`);",
                  "        console.log(`      Subject: ${entry.subjectId} (${entry.subjectType})`);",
                  "        console.log(`      Relationships: ${entry.relationships.join(', ')}`);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the ACL was correctly transformed from NMD format (VESD) to SpiceDB relations (viewer, editor, sharer, administrator)."
          },
          "response": []
        },
        {
          "name": "Validate ModNums",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Modification Numbers');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ModNums', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.docModNum).to.not.be.null;",
                  "    pm.expect(doc.nameModNum).to.not.be.null;",
                  "    pm.expect(doc.contentModNum).to.not.be.null;",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "pm.test('ModNums are valid ISO 8601 timestamps', function () {",
                  "    var isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;",
                  "    pm.expect(doc.docModNum).to.match(isoRegex);",
                  "    pm.expect(doc.nameModNum).to.match(isoRegex);",
                  "    pm.expect(doc.contentModNum).to.match(isoRegex);",
                  "});",
                  "",
                  "pm.test('Document has modified timestamp', function () {",
                  "    pm.expect(doc.modified).to.have.property('timestamp');",
                  "    pm.expect(doc.modified.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "pm.test('Document has created timestamp', function () {",
                  "    pm.expect(doc.created).to.have.property('timestamp');",
                  "    pm.expect(doc.created.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ ModNum Validation:');",
                  "console.log(`   DocModNum: ${doc.docModNum} (ISO 8601 format)`);",
                  "console.log(`   NameModNum: ${doc.nameModNum}`);",
                  "console.log(`   ContentModNum: ${doc.contentModNum}`);",
                  "console.log(`   Created: ${doc.created.timestamp}`);",
                  "console.log(`   Modified: ${doc.modified.timestamp}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that modification numbers (ModNums) were correctly set and incremented between scenarios."
          },
          "response": []
        },
        {
          "name": "Validation Summary",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üìä FINAL VALIDATION SUMMARY');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var doc = pm.response.json();",
                  "",
                  "console.log('');",
                  "console.log('üéâ ALL VALIDATIONS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã Complete Document State:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   Official Version: ${doc.officialVersion}`);",
                  "console.log(`   Next Version: ${doc.nextVersion}`);",
                  "console.log(`   Versions Count: ${doc.versions ? doc.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${doc.acl ? doc.acl.length : 0}`);",
                  "console.log(`   DocModNum: ${doc.docModNum}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);",
                  "console.log('');",
                  "console.log('‚úÖ Scenario 1 (CREATE): Verified');",
                  "console.log('‚úÖ Scenario 2 (UPDATE): Verified');",
                  "console.log('‚úÖ Data Integrity: Confirmed');",
                  "console.log('');",
                  "console.log('='.repeat(50));",
                  "console.log('‚úÖ POC VALIDATION SUCCESSFUL!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Final validation that prints a comprehensive summary of the document state after both scenarios."
          },
          "response": []
        }
      ]
    },
    {
      "name": "10 - Test Scenario: Archived Document",
      "item": [
        {
          "name": "Step 1: Load Archived Document Sample",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Load Archived Document sample",
                  "const sample = pm.environment.get('sample_archived');",
                  "",
                  "if (sample) {",
                  "    const msg = JSON.parse(sample);",
                  "    ",
                  "    // Generate dynamic document ID",
                  "    function generateDocId() {",
                  "        const randomPart = () => Math.floor(1000 + Math.random() * 9000);",
                  "        return `${randomPart()}-${randomPart()}-${randomPart()}`;",
                  "    }",
                  "    ",
                  "    const newDocId = generateDocId();",
                  "    const originalDocId = msg.documents[\"1\"].docProps.id;",
                  "    const cabId = msg.envProps.containingcabs[0];",
                  "    ",
                  "    let updatedSample = sample.replace(new RegExp(originalDocId, \"g\"), newDocId);",
                  "    ",
                  "    pm.environment.set(\"nmdMessage\", updatedSample);",
                  "    pm.environment.set(\"documentId\", newDocId);",
                  "    pm.environment.set(\"cabinetId\", cabId);",
                  "    ",
                  "    console.log('üìÑ TEST SCENARIO: ARCHIVED DOCUMENT');",
                  "    console.log(\"=\".repeat(60));",
                  "    console.log('   Archived document (status=1)');",
                  "    console.log('   üóÉÔ∏è Note: Tests basic status flag handling');",
                  "    console.log(`   Document ID: ${newDocId}`);",
                  "    console.log(\"=\".repeat(60));",
                  "} else {",
                  "    console.error(\"‚ùå Sample not found in environment\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Sample loaded\", function () {",
                  "    pm.expect(pm.environment.get(\"nmdMessage\")).to.not.be.empty;",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Extract Content Metadata from NMD",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Extract content-related metadata from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('sample_archived'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const version = doc.versions['1'];",
                  "",
                  "// Extract filename and extension",
                  "const docName = doc.docProps.name;",
                  "const extension = version.verProps.exten;",
                  "const filename = `${docName}.${extension}`;",
                  "",
                  "// Extract user ID and timestamp",
                  "const userId = nmdMessage.envProps.authorguid;",
                  "const createdTimestamp = new Date(parseInt(version.verProps.created.match(/\\d+/)[0])).toISOString();",
                  "",
                  "// Save to environment",
                  "pm.environment.set('contentFilename', filename);",
                  "pm.environment.set('contentExtension', extension);",
                  "pm.environment.set('userId', userId);",
                  "",
                  "console.log('');",
                  "console.log('üìÑ CONTENT METADATA EXTRACTION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üî§ Extension: ${extension}`);",
                  "console.log(`üë§ User ID: ${userId}`);",
                  "console.log(`‚è∞ Created: ${createdTimestamp}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// This is just a setup request, no actual HTTP call needed",
                  "pm.test('Content metadata extracted', function () {",
                  "    const filename = pm.environment.get('contentFilename');",
                  "    const extension = pm.environment.get('contentExtension');",
                  "    const userId = pm.environment.get('userId');",
                  "    ",
                  "    pm.expect(filename).to.not.be.empty;",
                  "    pm.expect(extension).to.not.be.empty;",
                  "    pm.expect(userId).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Content metadata ready for snapshot creation');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Extracts content metadata from NMD message (filename, extension, userId) needed for snapshot creation.\n\nThis is a dummy request that only runs pre-request script to set up variables."
          },
          "response": []
        },
        {
          "name": "Create Snapshot & Get Presigned URL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('üì∏ CREATING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìù Filename: ${filename}`);",
                  "console.log(`üåê Requesting presigned URL from Content API...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot created successfully', function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
                  "});",
                  "",
                  "const response = pm.response.json();",
                  "",
                  "pm.test('Response contains presigned URL', function () {",
                  "    pm.expect(response.presignedUrl).to.be.a('string');",
                  "    pm.expect(response.presignedUrl).to.include('s3');",
                  "});",
                  "",
                  "// Note: entityId is null initially, gets generated after content upload",
                  "pm.test('Response has entityId field', function () {",
                  "    pm.expect(response).to.have.property('entityId');",
                  "});",
                  "",
                  "// Save presigned URL and object key for later verification",
                  "pm.environment.set('presignedUrl', response.presignedUrl);",
                  "pm.environment.set('snapshotObjectKey', response.objectKey);",
                  "",
                  "console.log('‚úÖ Snapshot created:');",
                  "console.log(`   üì¶ Object Key: ${response.objectKey}`);",
                  "console.log(`   üîó Presigned URL: ${response.presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"contentType\": \"text/plain\",\n  \"filename\": \"{{contentFilename}}\",\n  \"extension\": \"{{contentExtension}}\",\n  \"createdByUserId\": \"{{userId}}\",\n  \"createdTimestamp\": \"{{$isoTimestamp}}\",\n  \"location\": \"poc-test\",\n  \"source\": \"doc-ndserver-sync-wrk-poc\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Creates a snapshot entity in the Content API and retrieves a presigned S3 URL for uploading the document content.\n\nThis corresponds to Phase 1.3 in the integration test."
          },
          "response": []
        },
        {
          "name": "Upload Content to S3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const presignedUrl = pm.environment.get('presignedUrl');",
                  "const filename = pm.environment.get('contentFilename');",
                  "",
                  "console.log('');",
                  "console.log('‚òÅÔ∏è  UPLOADING TO S3');",
                  "console.log('='.repeat(50));",
                  "console.log(`üìù File: ${filename}`);",
                  "console.log(`üîó URL: ${presignedUrl.substring(0, 80)}...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Content uploaded to S3 successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "console.log('‚úÖ Content uploaded successfully to S3');",
                  "console.log('   üì¶ Document now has both metadata AND content');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/octet-stream"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "This is test content for POC document {{documentId}}.\nCreated at: {{$isoTimestamp}}\nFilename: {{contentFilename}}\n\nThis content was uploaded as part of the doc-ndserver-sync-wrk POC test to verify the complete document lifecycle including content upload to S3."
            },
            "url": {
              "raw": "{{presignedUrl}}",
              "host": [
                "{{presignedUrl}}"
              ]
            },
            "description": "Uploads the document content to S3 using the presigned URL obtained from the Content API.\n\nThis corresponds to Phase 1.4 in the integration test."
          },
          "response": []
        },
        {
          "name": "Verify Snapshot Exists",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "const snapshotId = pm.environment.get('snapshotId');",
                  "",
                  "console.log('');",
                  "console.log('üîç VERIFYING SNAPSHOT');",
                  "console.log('='.repeat(50));",
                  "console.log(`üÜî Document ID: ${docId}`);",
                  "console.log(`üìã Snapshot ID: ${snapshotId}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Snapshot retrieved successfully', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "const snapshotResponse = pm.response.json();",
                  "const snapshots = snapshotResponse.results || snapshotResponse;",
                  "const objectKey = pm.environment.get('snapshotObjectKey');",
                  "const expectedExtension = pm.environment.get('contentExtension');",
                  "",
                  "pm.test('Snapshot list contains snapshots', function () {",
                  "    pm.expect(snapshots).to.be.an('array');",
                  "    pm.expect(snapshots.length).to.be.at.least(1);",
                  "});",
                  "",
                  "// Find snapshot by objectKey since entityId is generated after upload",
                  "const createdSnapshot = snapshots.find(s => s.objectKey === objectKey);",
                  "",
                  "pm.test('Created snapshot found in list', function () {",
                  "    pm.expect(createdSnapshot).to.not.be.undefined;",
                  "});",
                  "",
                  "pm.test('Snapshot has correct extension', function () {",
                  "    pm.expect(createdSnapshot.extension).to.equal(expectedExtension);",
                  "});",
                  "",
                  "pm.test('Snapshot has content uploaded', function () {",
                  "    pm.expect(createdSnapshot.length).to.be.above(0);",
                  "});",
                  "",
                  "console.log('‚úÖ Snapshot verified:');",
                  "console.log(`   üìã Entity ID: ${createdSnapshot.entityId}`);",
                  "console.log(`   üî§ Extension: ${createdSnapshot.extension}`);",
                  "console.log(`   üì¶ Size: ${createdSnapshot.length} bytes`);",
                  "console.log(`   ‚úîÔ∏è  Content upload complete!`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}"
              }
            ],
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/versions/1/snapshots",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "versions",
                "1",
                "snapshots"
              ]
            },
            "description": "Verifies that the snapshot was successfully created and contains the uploaded content."
          },
          "response": []
        },
        {
          "name": "S1 - Step 1: Check Document Existence (Expect 404)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "pm.environment.set('nmdMessage', pm.environment.get('nmdMessage_scenario1'));",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 1: NEW DOCUMENT CREATION');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 404 (document doesn't exist)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(404);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'true');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document not found (404)');",
                  "console.log('   Ready to CREATE new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Checks if the document already exists in the metadata API.\n\nExpected for POC: 404 Not Found (new document)"
          },
          "response": []
        },
        {
          "name": "S1 - Step 2: Configure Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Build documentRoot from NMD message",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "",
                  "// Format: [\"NG-CABID/documents\"]",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "",
                  "console.log(`üìÅ Configuring content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Status code is 204 (content root set)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario1_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root configured for new document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            },
            "description": "Updates the content service metadata to set the document root location.\n\nThis configures where content files are stored in S3."
          },
          "response": []
        },
        {
          "name": "S1 - Step 3: Build CREATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === MINIMAL TRANSFORMATION FOR POC ===",
                  "// This is a simplified version for new document creation only",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "// Helper: Convert NetDocuments date format",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "// Helper: Build ACL",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = {",
                  "        'V': 'viewer',",
                  "        'E': 'editor',",
                  "        'S': 'sharer',",
                  "        'D': 'administrator',",
                  "        'Z': 'default'",
                  "    };",
                  "    ",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        ",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        ",
                  "        return {",
                  "            SubjectType: subjectType,",
                  "            SubjectId: entry.guid,",
                  "            Relations: relations",
                  "        };",
                  "    });",
                  "}",
                  "",
                  "// Helper: Build versions list",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    ",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        ",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: {",
                  "                UserId: props.creatorguid,",
                  "                Timestamp: convertDate(props.created)",
                  "            },",
                  "            Modified: {",
                  "                UserId: props.modifiedByGuid || props.creatorguid,",
                  "                Timestamp: convertDate(props.modified || props.created)",
                  "            },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    ",
                  "    return versionsList;",
                  "}",
                  "",
                  "// Build minimal patch request for NEW document",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: docProps.name,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum),",
                  "    NameModNum: parseInt(docProps.nameModNum),",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: {",
                  "        UserId: envProps.authorguid,",
                  "        Timestamp: convertDate(envProps.created)",
                  "    },",
                  "    Modified: {",
                  "        UserId: envProps['modified by guid'],",
                  "        Timestamp: convertDate(envProps.modified)",
                  "    },",
                  "    CheckedOut: {",
                  "        UserId: null,",
                  "        Timestamp: null,",
                  "        Comment: null,",
                  "        CollaborationEdit: null,",
                  "        CollaborationEditType: null",
                  "    },",
                  "    Locked: {",
                  "        UserId: null,",
                  "        Comment: null,",
                  "        Timestamp: null",
                  "    },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "",
                  "console.log('‚úÖ CREATE patch request built');",
                  "console.log(`   Document: ${patchRequest.Name}`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to CREATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            },
            "description": "Builds the patch request by transforming the NMD message.\n\nThis is a dummy request that only runs the pre-request script to build the patchRequest variable.\n\nFor POC: Simplified transformation for new document creation only."
          },
          "response": []
        },
        {
          "name": "S1 - Step 4: CREATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üöÄ CREATING new document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S1] Document created successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "",
                  "// Store created document for Scenario 2",
                  "pm.environment.set('scenario1_created_document', JSON.stringify(response));",
                  "pm.environment.set('scenario1_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 1 COMPLETE: Document CREATED');",
                  "console.log('üìä Created Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Cabinet ID: ${response.cabinetId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${response.acl ? response.acl.length : 0}`);",
                  "console.log('');",
                  "console.log('‚û°Ô∏è  Document ready for Scenario 2 (UPDATE)');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Creates/updates the document in the metadata API.\n\nFor POC: Creates a new document with metadata, versions, and ACLs.\n\nThis is the main synchronization call."
          },
          "response": []
        },
        {
          "name": "S2 - Step 1: Check Document Existence (Expect 200)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const docId = pm.environment.get('documentId');",
                  "",
                  "console.log('');",
                  "console.log('üé¨ SCENARIO 2: DOCUMENT UPDATE');",
                  "console.log('='.repeat(50));",
                  "console.log(`üîç Checking if document ${docId} exists (should be 200)...`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 200 (document exists)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var extendedDoc = pm.response.json();",
                  "pm.environment.set('existingDocument', JSON.stringify(extendedDoc));",
                  "pm.environment.set('scenario2_step1_status', pm.response.code.toString());",
                  "pm.environment.set('isNewDocument', 'false');",
                  "",
                  "console.log('‚úÖ EXPECTED: Document found (200 OK)');",
                  "console.log(`   Document State: ${extendedDoc.state}`);",
                  "console.log(`   Current Versions: ${extendedDoc.versions ? extendedDoc.versions.length : 0}`);",
                  "console.log('   Ready to UPDATE existing document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 2: Update Content Root",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const cabinetId = nmdMessage.envProps.containingcabs[0];",
                  "const documentRoot = [`${cabinetId}/documents`];",
                  "",
                  "pm.environment.set('documentRoot', JSON.stringify(documentRoot));",
                  "console.log(`üìÅ Updating content root: ${JSON.stringify(documentRoot)}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Status code is 204 (content root updated)\", function () {",
                  "    pm.expect(pm.response.code).to.be.oneOf([200, 204]);",
                  "});",
                  "",
                  "pm.environment.set('scenario2_step2_status', pm.response.code.toString());",
                  "console.log('‚úÖ Content root updated');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{contentToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"documentRoot\": {{documentRoot}},\n  \"source\": \"doc-ndserver-sync-wrk\"\n}"
            },
            "url": {
              "raw": "{{contentBaseUrl}}/v1/content/{{documentId}}/metadata",
              "host": [
                "{{contentBaseUrl}}"
              ],
              "path": [
                "v1",
                "content",
                "{{documentId}}",
                "metadata"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 3: Build UPDATE Patch Request",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// === BUILD PATCH REQUEST FOR UPDATING DOCUMENT ===",
                  "// This simulates a change: update document name with timestamp",
                  "",
                  "const nmdMessage = JSON.parse(pm.environment.get('nmdMessage_scenario1'));",
                  "const doc = nmdMessage.documents['1'];",
                  "const docProps = doc.docProps;",
                  "const envProps = nmdMessage.envProps;",
                  "",
                  "function convertDate(dateStr) {",
                  "    if (!dateStr) return null;",
                  "    const match = dateStr.match(/\\d+/);",
                  "    if (!match) return null;",
                  "    return new Date(parseInt(match[0])).toISOString();",
                  "}",
                  "",
                  "function buildAcl(nmdAcl) {",
                  "    const rightsMap = { 'V': 'viewer', 'E': 'editor', 'S': 'sharer', 'D': 'administrator', 'Z': 'default' };",
                  "    return (nmdAcl || []).map(entry => {",
                  "        const relations = entry.rights.split('').map(r => rightsMap[r]).filter(Boolean);",
                  "        let subjectType = 'user';",
                  "        if (entry.guid.startsWith('UG-')) subjectType = 'group';",
                  "        if (entry.guid.startsWith('NG-') || entry.guid.startsWith('CA-')) subjectType = 'cabinet';",
                  "        return { SubjectType: subjectType, SubjectId: entry.guid, Relations: relations };",
                  "    });",
                  "}",
                  "",
                  "function buildVersions(versions) {",
                  "    const versionsList = [];",
                  "    for (const [versionId, versionData] of Object.entries(versions || {})) {",
                  "        const props = versionData.verProps;",
                  "        versionsList.push({",
                  "            VersionId: parseInt(versionId),",
                  "            Name: versionId,",
                  "            Description: props.description || '',",
                  "            Extension: props.exten,",
                  "            Label: props.verLabel,",
                  "            Size: props.size,",
                  "            Locked: false,",
                  "            DeliveryRevoked: false,",
                  "            Created: { UserId: props.creatorguid, Timestamp: convertDate(props.created) },",
                  "            Modified: { UserId: props.modifiedByGuid || props.creatorguid, Timestamp: convertDate(props.modified || props.created) },",
                  "            State: 'ACTIVE',",
                  "            CopiedFrom: null,",
                  "            LegacySignatures: null",
                  "        });",
                  "    }",
                  "    return versionsList;",
                  "}",
                  "",
                  "// SIMULATE A CHANGE: Update document name",
                  "const updatedName = docProps.name + ' [UPDATED]';",
                  "const now = new Date().toISOString();",
                  "",
                  "const patchRequest = {",
                  "    DocumentId: docProps.id,",
                  "    CabinetId: envProps.containingcabs[0],",
                  "    Name: updatedName,",
                  "    State: 'ACTIVE',",
                  "    OfficialVersion: docProps.lastVerNo,",
                  "    NextVersion: docProps.lastVerNo + 1,",
                  "    EnvUrl: envProps.url,",
                  "    ParentFolders: [],",
                  "    FolderTree: [],",
                  "    AclFreeze: false,",
                  "    DocModNum: parseInt(envProps.docmodnum) + 1,",
                  "    NameModNum: parseInt(docProps.nameModNum) + 1,",
                  "    ContentModNum: parseInt(docProps.contentModNum),",
                  "    DocNum: docProps.docNum,",
                  "    Created: { UserId: envProps.authorguid, Timestamp: convertDate(envProps.created) },",
                  "    Modified: { UserId: envProps['modified by guid'], Timestamp: now },",
                  "    CheckedOut: { UserId: null, Timestamp: null, Comment: null, CollaborationEdit: null, CollaborationEditType: null },",
                  "    Locked: { UserId: null, Comment: null, Timestamp: null },",
                  "    LinkedDocuments: [],",
                  "    CustomAttributes: [],",
                  "    Versions: buildVersions(doc.versions),",
                  "    Acl: buildAcl(envProps.acl),",
                  "    RepositoryId: '',",
                  "    PolicyId: '',",
                  "    ClassificationId: '',",
                  "    DeletedCabinets: [],",
                  "    Alerts: [],",
                  "    Approval: null",
                  "};",
                  "",
                  "pm.environment.set('patchRequest', JSON.stringify(patchRequest, null, 2));",
                  "console.log('‚úÖ UPDATE patch request built');",
                  "console.log(`   CHANGE: Name updated to: ${updatedName}`);",
                  "console.log(`   CHANGE: Modified timestamp: ${now}`);",
                  "console.log(`   CHANGE: DocModNum incremented`);",
                  "console.log(`   Versions: ${patchRequest.Versions.length}`);",
                  "console.log(`   ACL Entries: ${patchRequest.Acl.length}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Patch request variable is set\", function () {",
                  "    pm.expect(pm.environment.get('patchRequest')).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('‚úÖ Ready to UPDATE document');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "https://postman-echo.com/get",
              "protocol": "https",
              "host": [
                "postman-echo",
                "com"
              ],
              "path": [
                "get"
              ]
            }
          },
          "response": []
        },
        {
          "name": "S2 - Step 4: UPDATE Document",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('üîÑ UPDATING existing document in metadata API...');"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"[S2] Document updated successfully (200 OK)\", function () {",
                  "    pm.expect(pm.response.code).to.equal(200);",
                  "});",
                  "",
                  "var response = pm.response.json();",
                  "pm.environment.set('scenario2_updated_document', JSON.stringify(response));",
                  "pm.environment.set('scenario2_step4_status', pm.response.code.toString());",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ SCENARIO 2 COMPLETE: Document UPDATED');",
                  "console.log('üìä Updated Document:');",
                  "console.log(`   Document ID: ${response.documentId}`);",
                  "console.log(`   Name: ${response.name}`);",
                  "console.log(`   State: ${response.state}`);",
                  "console.log(`   Versions: ${response.versions ? response.versions.length : 0}`);",
                  "console.log('');",
                  "console.log('üéâ BOTH SCENARIOS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã SUMMARY:');",
                  "console.log(`   Scenario 1 - Step 1: ${pm.environment.get('scenario1_step1_status')} (Expected: 404)`);",
                  "console.log(`   Scenario 1 - Step 4: ${pm.environment.get('scenario1_step4_status')} (Expected: 200 - CREATE)`);",
                  "console.log(`   Scenario 2 - Step 1: ${pm.environment.get('scenario2_step1_status')} (Expected: 200 - EXISTS)`);",
                  "console.log(`   Scenario 2 - Step 4: ${pm.environment.get('scenario2_step4_status')} (Expected: 200 - UPDATE)`);",
                  "console.log('');",
                  "console.log('‚úÖ POC validated BOTH workflows successfully!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{patchRequest}}"
            },
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            }
          },
          "response": []
        },
        {
          "name": "Validate Document Metadata",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Document Metadata');",
                  "console.log('='.repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get('documentId')}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document exists (200 OK)', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "var expectedDocId = pm.environment.get('documentId');",
                  "",
                  "pm.test('Document ID matches', function () {",
                  "    pm.expect(doc.documentId).to.eql(expectedDocId);",
                  "});",
                  "",
                  "pm.test('Document state is ACTIVE', function () {",
                  "    pm.expect(doc.state).to.eql('ACTIVE');",
                  "});",
                  "",
                  "pm.test('Cabinet ID is set', function () {",
                  "    pm.expect(doc.cabinetId).to.not.be.empty;",
                  "    pm.expect(doc.cabinetId).to.eql('NG-8RZI6EOH');",
                  "});",
                  "",
                  "pm.test('Document name was updated in Scenario 2', function () {",
                  "    pm.expect(doc.name).to.include('[UPDATED]');",
                  "});",
                  "",
                  "pm.test('EnvUrl is set', function () {",
                  "    pm.expect(doc.envUrl).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ Document Metadata Validation:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document created in Scenario 1 and updated in Scenario 2 exists with correct metadata."
          },
          "response": []
        },
        {
          "name": "Validate Versions",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Version Information');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has versions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.versions).to.be.an('array');",
                  "    pm.expect(doc.versions.length).to.be.at.least(1);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.versions && doc.versions.length > 0) {",
                  "    var version1 = doc.versions[0];",
                  "    ",
                  "    pm.test('Version 1 exists', function () {",
                  "        pm.expect(version1.versionId).to.eql(1);",
                  "    });",
                  "    ",
                  "    pm.test('Version has extension', function () {",
                  "        pm.expect(version1.extension).to.eql('txt');",
                  "    });",
                  "    ",
                  "    pm.test('Version has label', function () {",
                  "        pm.expect(version1.label).to.eql('1.0');",
                  "    });",
                  "    ",
                  "    pm.test('Version state is ACTIVE', function () {",
                  "        pm.expect(version1.state).to.eql('ACTIVE');",
                  "    });",
                  "    ",
                  "    pm.test('Version has created timestamp', function () {",
                  "        pm.expect(version1.created).to.have.property('timestamp');",
                  "        pm.expect(version1.created.timestamp).to.not.be.empty;",
                  "    });",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ Version Validation:');",
                  "    console.log(`   Version ID: ${version1.versionId}`);",
                  "    console.log(`   Label: ${version1.label}`);",
                  "    console.log(`   Extension: ${version1.extension}`);",
                  "    console.log(`   Size: ${version1.size} bytes`);",
                  "    console.log(`   State: ${version1.state}`);",
                  "    console.log(`   Created: ${version1.created.timestamp}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the document has the correct version information from the NMD message."
          },
          "response": []
        },
        {
          "name": "Validate ACL",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying ACL Configuration');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ACL permissions', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.aclPermissions).to.be.an('object');",
                  "    pm.expect(doc.aclPermissions.relationships).to.be.an('array');",
                  "    pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "if (doc.aclPermissions && doc.aclPermissions.relationships) {",
                  "    pm.test('ACL has expected entries', function () {",
                  "        pm.expect(doc.aclPermissions.relationships.length).to.be.at.least(2);",
                  "    });",
                  "    ",
                  "    var groupAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'UG-LGSFSO0I');",
                  "    var userAcl = doc.aclPermissions.relationships.find(entry => entry.subjectId === 'DUCOT-pbs.nonadmin');",
                  "    ",
                  "    pm.test('Group ACL entry exists', function () {",
                  "        pm.expect(groupAcl).to.not.be.undefined;",
                  "        pm.expect(groupAcl.subjectType).to.eql('group');",
                  "    });",
                  "    ",
                  "    pm.test('User ACL entry exists', function () {",
                  "        pm.expect(userAcl).to.not.be.undefined;",
                  "        pm.expect(userAcl.subjectType).to.eql('user');",
                  "    });",
                  "    ",
                  "    pm.test('ACL has correct relationships (VESD)', function () {",
                  "        pm.expect(groupAcl.relationships).to.include('viewer');",
                  "        pm.expect(groupAcl.relationships).to.include('editor');",
                  "        pm.expect(groupAcl.relationships).to.include('sharer');",
                  "        pm.expect(groupAcl.relationships).to.include('administrator');",
                  "    });",
                  "    ",
                  "    // ACL MODIFICATION TESTS (optional - only run if scenario1Message exists)",
                  "    const scenario1Message = pm.environment.get('nmdMessage_scenario1');",
                  "    const scenario2Message = pm.environment.get('nmdMessage_scenario2');",
                  "    ",
                  "    if (scenario1Message && scenario2Message) {",
                  "        const msg1 = JSON.parse(scenario1Message);",
                  "        const msg2 = JSON.parse(scenario2Message);",
                  "        ",
                  "        // Check if this is an ACL modification test",
                  "        if (msg1.documents && msg1.documents['1'].docProps.name.includes('ACL Modification')) {",
                  "            console.log('');",
                  "            console.log('üî¨ ACL MODIFICATION TEST DETECTED');",
                  "            console.log('   Running enhanced ACL validation...');",
                  "            ",
                  "            const initialAcl = msg1.envProps.acl || [];",
                  "            const modifiedAcl = msg2.envProps.acl || [];",
                  "            const actualAcl = doc.aclPermissions.relationships;",
                  "            ",
                  "            pm.test('ACL Modification: Entry count matches modified sample', function () {",
                  "                pm.expect(actualAcl.length).to.equal(modifiedAcl.length);",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New user DUCOT-user2 present', function () {",
                  "                const user2 = actualAcl.find(e => e.subjectId === 'DUCOT-user2');",
                  "                pm.expect(user2).to.not.be.undefined;",
                  "                pm.expect(user2.subjectType).to.eql('user');",
                  "                pm.expect(user2.relationships).to.include('viewer');",
                  "                pm.expect(user2.relationships).to.include('editor');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: New group UG-NEWGROUP present', function () {",
                  "                const newGroup = actualAcl.find(e => e.subjectId === 'UG-NEWGROUP');",
                  "                pm.expect(newGroup).to.not.be.undefined;",
                  "                pm.expect(newGroup.subjectType).to.eql('group');",
                  "                pm.expect(newGroup.relationships).to.include('viewer');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: Cabinet NG-8RZI6EOH removed', function () {",
                  "                const cabinet = actualAcl.find(e => e.subjectId === 'NG-8RZI6EOH');",
                  "                pm.expect(cabinet).to.be.undefined;",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: DUCOT-pbs.nonadmin permissions modified (VE only)', function () {",
                  "                const user = actualAcl.find(e => e.subjectId === 'DUCOT-pbs.nonadmin');",
                  "                pm.expect(user).to.not.be.undefined;",
                  "                pm.expect(user.relationships).to.include('viewer');",
                  "                pm.expect(user.relationships).to.include('editor');",
                  "                pm.expect(user.relationships).to.not.include('sharer');",
                  "                pm.expect(user.relationships).to.not.include('administrator');",
                  "            });",
                  "            ",
                  "            pm.test('ACL Modification: UG-LGSFSO0I unchanged (VESD)', function () {",
                  "                const group = actualAcl.find(e => e.subjectId === 'UG-LGSFSO0I');",
                  "                pm.expect(group).to.not.be.undefined;",
                  "                pm.expect(group.relationships).to.include('viewer');",
                  "                pm.expect(group.relationships).to.include('editor');",
                  "                pm.expect(group.relationships).to.include('sharer');",
                  "                pm.expect(group.relationships).to.include('administrator');",
                  "            });",
                  "            ",
                  "            console.log('   ‚úÖ ACL modification validation complete');",
                  "        }",
                  "    }",
                  "    ",
                  "    console.log('');",
                  "    console.log('‚úÖ ACL Validation:');",
                  "    console.log(`   Object Type: ${doc.aclPermissions.objectType}`);",
                  "    console.log(`   Object ID: ${doc.aclPermissions.objectId}`);",
                  "    console.log(`   Total ACL Entries: ${doc.aclPermissions.relationships.length}`);",
                  "    doc.aclPermissions.relationships.forEach((entry, idx) => {",
                  "        console.log(`   Entry ${idx + 1}:`);",
                  "        console.log(`      Subject: ${entry.subjectId} (${entry.subjectType})`);",
                  "        console.log(`      Relationships: ${entry.relationships.join(', ')}`);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that the ACL was correctly transformed from NMD format (VESD) to SpiceDB relations (viewer, editor, sharer, administrator)."
          },
          "response": []
        },
        {
          "name": "Validate ModNums",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üîç VALIDATION: Verifying Modification Numbers');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Document has ModNums', function () {",
                  "    pm.response.to.have.status(200);",
                  "    var doc = pm.response.json();",
                  "    pm.expect(doc.docModNum).to.not.be.null;",
                  "    pm.expect(doc.nameModNum).to.not.be.null;",
                  "    pm.expect(doc.contentModNum).to.not.be.null;",
                  "});",
                  "",
                  "var doc = pm.response.json();",
                  "",
                  "pm.test('ModNums are valid ISO 8601 timestamps', function () {",
                  "    var isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;",
                  "    pm.expect(doc.docModNum).to.match(isoRegex);",
                  "    pm.expect(doc.nameModNum).to.match(isoRegex);",
                  "    pm.expect(doc.contentModNum).to.match(isoRegex);",
                  "});",
                  "",
                  "pm.test('Document has modified timestamp', function () {",
                  "    pm.expect(doc.modified).to.have.property('timestamp');",
                  "    pm.expect(doc.modified.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "pm.test('Document has created timestamp', function () {",
                  "    pm.expect(doc.created).to.have.property('timestamp');",
                  "    pm.expect(doc.created.timestamp).to.not.be.empty;",
                  "});",
                  "",
                  "console.log('');",
                  "console.log('‚úÖ ModNum Validation:');",
                  "console.log(`   DocModNum: ${doc.docModNum} (ISO 8601 format)`);",
                  "console.log(`   NameModNum: ${doc.nameModNum}`);",
                  "console.log(`   ContentModNum: ${doc.contentModNum}`);",
                  "console.log(`   Created: ${doc.created.timestamp}`);",
                  "console.log(`   Modified: ${doc.modified.timestamp}`);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Validates that modification numbers (ModNums) were correctly set and incremented between scenarios."
          },
          "response": []
        },
        {
          "name": "Validation Summary",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log('');",
                  "console.log('üìä FINAL VALIDATION SUMMARY');",
                  "console.log('='.repeat(50));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "var doc = pm.response.json();",
                  "",
                  "console.log('');",
                  "console.log('üéâ ALL VALIDATIONS COMPLETE!');",
                  "console.log('='.repeat(50));",
                  "console.log('');",
                  "console.log('üìã Complete Document State:');",
                  "console.log(`   Document ID: ${doc.documentId}`);",
                  "console.log(`   Name: ${doc.name}`);",
                  "console.log(`   State: ${doc.state}`);",
                  "console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "console.log(`   Official Version: ${doc.officialVersion}`);",
                  "console.log(`   Next Version: ${doc.nextVersion}`);",
                  "console.log(`   Versions Count: ${doc.versions ? doc.versions.length : 0}`);",
                  "console.log(`   ACL Entries: ${doc.acl ? doc.acl.length : 0}`);",
                  "console.log(`   DocModNum: ${doc.docModNum}`);",
                  "console.log(`   EnvUrl: ${doc.envUrl}`);",
                  "console.log('');",
                  "console.log('‚úÖ Scenario 1 (CREATE): Verified');",
                  "console.log('‚úÖ Scenario 2 (UPDATE): Verified');",
                  "console.log('‚úÖ Data Integrity: Confirmed');",
                  "console.log('');",
                  "console.log('='.repeat(50));",
                  "console.log('‚úÖ POC VALIDATION SUCCESSFUL!');"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Final validation that prints a comprehensive summary of the document state after both scenarios."
          },
          "response": []
        }
      ]
    },
    {
      "name": "99 - Supporting API Calls",
      "item": [
        {
          "name": "Get Document by ID (Extended)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log(\"üîç FETCHING EXTENDED DOCUMENT\");",
                  "console.log(\"=\".repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get(\"documentId\")}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    const doc = pm.response.json();",
                  "    console.log(\"\n‚úÖ Document Retrieved:\");",
                  "    console.log(`   Name: ${doc.name}`);",
                  "    console.log(`   State: ${doc.state}`);",
                  "    console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "    console.log(`   Versions: ${doc.versions?.length || 0}`);",
                  "    console.log(`   ACL Entries: ${doc.acl?.length || 0}`);",
                  "    console.log(`   Custom Attributes: ${doc.customAttributes?.length || 0}`);",
                  "} else if (pm.response.code === 404) {",
                  "    console.log(\"‚ùå Document not found\");",
                  "} else {",
                  "    console.log(`‚ö†Ô∏è Unexpected response: ${pm.response.code}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/extended/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "extended",
                "{{documentId}}"
              ]
            },
            "description": "Retrieve complete document metadata including versions, ACL, custom attributes, and all related metadata."
          },
          "response": []
        },
        {
          "name": "Get Document by ID (Basic)",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log(\"üîç FETCHING BASIC DOCUMENT\");",
                  "console.log(\"=\".repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get(\"documentId\")}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    const doc = pm.response.json();",
                  "    console.log(\"\n‚úÖ Basic Document Retrieved:\");",
                  "    console.log(`   Name: ${doc.name}`);",
                  "    console.log(`   State: ${doc.state}`);",
                  "    console.log(`   Cabinet: ${doc.cabinetId}`);",
                  "} else if (pm.response.code === 404) {",
                  "    console.log(\"‚ùå Document not found\");",
                  "} else {",
                  "    console.log(`‚ö†Ô∏è Unexpected response: ${pm.response.code}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "{{documentId}}"
              ]
            },
            "description": "Retrieve basic document metadata only (without versions, ACL, or extended information)."
          },
          "response": []
        },
        {
          "name": "Delete Document by ID",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log(\"‚ö†Ô∏è DELETING DOCUMENT\");",
                  "console.log(\"=\".repeat(50));",
                  "console.log(`   Document ID: ${pm.environment.get(\"documentId\")}`);",
                  "console.log(\"   WARNING: This will permanently delete the document!\");"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 204 || pm.response.code === 200) {",
                  "    console.log(\"\n‚úÖ Document deleted successfully\");",
                  "} else if (pm.response.code === 404) {",
                  "    console.log(\"‚ùå Document not found\");",
                  "} else {",
                  "    console.log(`‚ö†Ô∏è Unexpected response: ${pm.response.code}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "DELETE",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/documents/{{documentId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "documents",
                "{{documentId}}"
              ]
            },
            "description": "‚ö†Ô∏è WARNING: Remove document from metadata store.\n\nUse with caution! This operation permanently deletes the document metadata.\n\nTypical use cases:\n- Cleanup after testing\n- Remove test documents\n- Manual data cleanup"
          },
          "response": []
        },
        {
          "name": "Get Cabinet Info",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "console.log(\"üóÑÔ∏è FETCHING CABINET INFO\");",
                  "console.log(\"=\".repeat(50));",
                  "console.log(`   Cabinet ID: ${pm.environment.get(\"cabinetId\")}`);"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    const cabinet = pm.response.json();",
                  "    console.log(\"\n‚úÖ Cabinet Retrieved:\");",
                  "    console.log(`   Cabinet ID: ${cabinet.cabinetId}`);",
                  "    console.log(`   Name: ${cabinet.name || \"N/A\"}`);",
                  "} else if (pm.response.code === 404) {",
                  "    console.log(\"‚ùå Cabinet not found\");",
                  "} else {",
                  "    console.log(`‚ö†Ô∏è Unexpected response: ${pm.response.code}`);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{metadataToken}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{metadataBaseUrl}}/v1/cabinets/{{cabinetId}}",
              "host": [
                "{{metadataBaseUrl}}"
              ],
              "path": [
                "v1",
                "cabinets",
                "{{cabinetId}}"
              ]
            },
            "description": "Retrieve cabinet metadata and settings.\n\nUseful for:\n- Verifying cabinet configuration\n- Debugging cabinet-level issues\n- Understanding cabinet context"
          },
          "response": []
        }
      ]
    }
  ]
}